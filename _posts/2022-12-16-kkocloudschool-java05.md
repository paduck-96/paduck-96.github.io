---
title: "Java 이론 5"
excerpt: "Java 생성자에 대해 학습하고,
자바의 상속, 추상화, 인터페이스에 대해 학습한다"

categories:
  - Blog
tags:
  - [Blog, kakaocloudschool, develop, java, extends, implements, abstract]

toc: true
toc_sticky: true

date: 2022-12-15
last_modified_at: 2022-12-15
---

# OOP

## 1. Constructor(생성자)

### Constructor

- `인스턴스를 생성할 때 호출하는 메서드`
- 생성자의 이름은 `클래스 이름과 동일`
- 생성자는 new 로 호출
- 생성자는 `메모리 할당을 수행`하고 `할당받은 메모리의 참조를 리턴`
- 생성자를 `만들지 않으면 매개변수가 없는 생성자 제공`
- 생성자를 `직접 작성하면 기본적으로 제공되는 생성자 소멸`
- 생성자는 `리턴 타입이 없음`

### 생성자 만들기

```java
[접근 지정자] 클래스이름(매개변수){
  수행할 작업
}
```

### 생성자 호출

new 생성자이름(매개변수)

### 생성자 생성 이유

- `인스턴스 속성들의 초기화`
  - 기본 값이 아닌 상수로 초기화
  - 외부로부터 주입(Injection) 받아 초기화
- `상위 클래스`에 매개변수가 없는 생성자(Default Constructor) `없어서 생성`

### 생성자 만들기

- VO(Value Object) 클래스 생성

  - 여러 개의 데이터를 하나로 묶어서 표현하기 위한 클래스
  - RDBMS 에서의 테이블  
    ex) 회원정보
  - email, 문자열
  - password, 문자열
  - nickname, 문자열 배열
  - birthday, Date 클래스
  - married, boolean
  - age, int

- 속성을 설정하기 위해 setter 메서드가 데이터만큼 호출되는데  
  데이터를 받을 경우 바로 초기화하는 것이 효율적
  - `생성하면서 초기화`
  - 매개변수 있는 생성자 만들면 기본 생성자 소멸되니  
    생성 시 `기본 생성자도 만들어주는 것 권장`
- 속성을 정의하는 것 이외의 작업들을 라이브러리의 어노테이션을 이용

### 일련번호 생성

- static 속성은 클래스 안에 1개만 만들어지고 instance 속성은 별도
- static 변수의 값을 시작할 번호로 초기화하고  
  생성자에서 static 변수 값 변경하면서 instance 에 대입
- getter 와 setter 를 만들어 제공하면 확인 및 재설정 작업 가능

### Instant Field Initializer

- 클래스 안에 { } 에 작성
  - `static 속성 과 instance 속성 모두 사용` 가능
- `instance 속성을 초기화`할 목적으로 사용
- 여러 개 작성 가능하고 생성자보다 먼저 호출
  - 내부적으로는 init 이라는 메서드로 생성

### 생성

- **클래스**  
  static 속성을 메모리 할당 후 static { } 코드를 수행
- **인스턴스**  
  instance 속성을 메모리 할당 후 { } 코드를 수행하고 생성자 수행

## 2. 메모리 정리

- `Garbage Collection 이 Heap(인스턴스 존재 영역)`  
  메모리에 대한 `정리 수행`
  - 더 이상 참조되지 않는 인스턴스가 정리 대상
- Garbage Collection 은 우`선순위가 낮은 Daemon Thread` 형태  
  `호출 순서가 늦다`
  - 정확한 `호출 시점 예측 어려움`
  - 강제 호출하는 System.gc( ) 메서드가 있지만  
    PC는 호출 가능  
    안드로이드 와 Server Application 에서는 호출 비권장

## 3. 초기화나 생성 시점

### Server Application 과 Client APplication

- 여러 클라이언트의 요청을 처리하는 **Server 앱**은 빠른 처리가 필수
  - 작업 처리 전 모든 준비를 해두는 것이 중요
- **Client 앱**은 속도 보다는 가용성 확보가 매우 필수
  - 사용 시 생성하거나 초기화해도 문제 없음

## 4. package

- `유사한 기능을 수행하는 클래스의 집합`
  - 디렉토리와 유사
- `배포의 단위`
- **하나의 패키지**에서 클래스 이름은 식별 되어야 함  
  **다른 패지키**끼리는 동일한 클래스 이름 가능
  - 패캐지이름.클래스이름 으로 만들어지므로
  - 이름1 과 이름1.이름2 형태의 패키지는 `서로 별개의 패키지`
- 배포할 때는 `압축을 해서 배포`
  - jar  
    자바 애플리케이션
    - main 메서드를 가진 클래스가 2개 이상이면 안됨
  - war  
    자바 웹 애플리케이션
  - 패키지 선택 후 우클릭 > export

## 5. Inheritance - is a

### **상속**

- 하위 클래스가 상위 클래스의 모든 멤버를 물려받는 것

#### - 장점

- 여러 클래스 들에 `중복되는 코드를 1번만 작성` 가능
  - `재사용성 증가`
  - 자신이 만든 클래스 상속  
    중복되는 코드 제거
  - 라이브러리 나 프레임워크의 클래스 상속  
    기능 확장

#### - 용어

- 단일 상속  
  하나의 클래스로부터 상속받는 경우
- 다중 상속  
  여러 개의 클래스로부터 상속받는 경우
- 상속하는 클래스  
  super(상위), base(기반)
- 상속받는 클래스  
  sub(하위), derivation(파생)

### java 상속 방법

```java
class 클래스이름 extends 상위 클래스 이름
```

- 자바는 `상위 클래스를 1개` 밖에 갖지 못함
- extends 를 생략하면 java.lang.Object 에서 상속받는 것으로 간주
  - java 의 최상위 클래스
- 상위 클래스의 `모든 멤버는 상속`되지만  
  하위 클래스에서 `private 멤버에 접근` 불가
- `초기화 블럭 과 생성자는 상속되지 않음`
- **static 변수**는 상속

  ```java
  // 상속 받고 상속하는 클래스 생성
  // 하위 클래스에서 상위 클래스 extends
  // private 접근
  ```

### super

- `하위 클래스의 instance 메서드에 숨겨진 매게변수`
- `상위 클래스의 멤버를 호출`하고자 할 때 사용
- instance 메서드에서 변수 이름을 사용하면  
  현재 메서드 내부 > 클래스의 속성 > 상위 클래스 확인 > 에러 출력
  - `this. 을 추가하면 자신의 메서드 안에서는 찾지 않아`  
    클래스 > 상위 클래스 순으로 확인
    - `super. 을 추가하면 상위 클래스에서만 확인`
    - 하위 와 상위가 동일한 속성이나 메서드를 가지고 있다면  
      상위 클래스는 super. 으로 상위 클래스 호출
  - 메서드 이름의 중복이 많아 super.메서드이름( ) 사용

### super( ), this( )

- super( )  
  생성자 안에서 `상위 클래스의 생성자를 호출`할 때 사용
  - 모든 클래스의 생성자에서 상위 클래스의 생성자를 호출하지 않으면  
    super( ) 가 가장 먼저 있는 것으로 간주
    - 상위 클래스의 기본 생성자 호출하는 문장이 있는 것으로 간주
  - `상위 클래스에 기본 생성자 없을 때 상속받으면 에러`
    - **기본 생성자 생성**(상위 클래스를 직접 생성했을 때)  
      하위 클래스에서 **생성자 생성 후 상위 클래스 생성자 호출**  
      (상위 클래스를 직접 생성하지 않은 경우)
      - 배포를 하면 소스 코드가 아닌 class 코드가 오기 때문에  
        class 를 수정할 수 없음
  - 상위 클래스의 생성자를 호출하는 super( ) 는 생성자 안에서 최우선
    - 상위 클래스의 인스턴스 만들고 하위 클래스의 인스턴스 추가
- this( )  
  생성자 안에서 `자신의 생성자를 호출`할 때 사용  
  `자신의 클래스에 속한 생성자를 호출`하는 구문
  - 여러 개의 생성자를 가진 경우  
    중복되는 내용이 있는 경우 사용
  - super( ) 다음에 나와야 함

### Method Overriding

- 하위 클래스에 `상위 클래스의 메서드 원형과 동일한 메서드` 생성
- 하위 클래스에 만드는 메서드의 접근 지정자가 더 크거나 같아야 함
  - `접근 지정자가 작은 쪽으로 overriding 불가`

#### - 목적

- `자신의 클래스에서 오버라이딩`  
  다형성 구현이 목적 이거나 기능 확장
- 직접 생성하지 않은 `클래스 메서드 오버라이딩`  
  대부분 기능 확장
- 특별한 경우(상위 클래스의 메서드에 내용이 없는 경우) 제외하고는  
   상위 클래스의 메서드 호출
  - 호출할 때 파괴를 하는 메서드가 아니라면 상위 클래스 메서드 먼저 호출
- **@Override 어노테이션**은 오버라이딩 유무를 알려주는 어노테이션  
  메서드가 상위 클래스에 존재하지 않는다면 에러 표시
  - **annotation**  
    반복되는 기능, 복잡한 기능을 구현하지 않고  
    `빌드 단계에서 삽입해주는 기능`으로 클래스 취급

### 참조형 변수의 대입

- **참조형 변수**에는 `자신의 참조형 데이터 참조만 대입 가능`
- `상속 관계`에서는 참조형 변수의 `하위 클래스의 인스턴스 참조 대입 가능`  
  `상위 클래스 참조형 변수`에는 하위 클래스의 인스턴스 참조 대입 X,  
  강제 형 변환으로 대입 가능
  - 인스턴스의 `원래 자료형이 하위 클래스 타입`이면 가능  
    그렇지 않으면 예외가 발생

### 참조형 변수의 멤버 호출

- 컴파일 단계에서는 변수를 `선언할 때 사용한 자료형`이 있는지  
  변수가 `자신의 자료형이 호출할 수 있는 멤버`를 호출하는지 확인
  - 에러 여부 결정
- 실행은 `실제 대입된 인스턴스를 가지고 자신이 호출할 수 있는 것` 결정

### Polymorphism(다형성)

- `동일한 메시지에 대하여 다르게 반응`하는 성질
- 동일한 코드가 `상황에 따라 다른 메서드` 호출
  - 대입된 인스턴스에 따라 다른 메서드 호출
- 이 원리로 인해 GUI 운영체제가 만들어졌고, 스마트폰 지역화 가능

### Abstract(추상)

#### - abstract method(추상 메서드)

- `내용이 없는 메서드로 오버라이딩을 위해 생성`  
  결과형 앞에 **abstract 라는 키워드**를 추가하고 **{ } 를 제거**해 생성
- abstract 메서드가 `abstract class 나 interface 에 존재`
- abstract 메서드를 소유한 class extends, interface implements 하면  
  `반드시 overriding` 을 해서 해당 내용을 만들어야 함

#### - abstract class(추상 클래스)

- `인스턴스를 생성할 수 없는 클래스`
- 다른 클래스에 `상속을 해서 사용`
- 참조형 변수의 자료형으로 사용 가능

## 6. Interface - Protocol

### 개요

- 상수(static final) 와 abstract method, default method 를 소유한 객체
- 인터페이스의 **변수**는 상수, **메서드**는 추상 메서드가 됨
- 인스턴스를 생성할 수는 없지만 변수의 자료형으로 사용 가능
- 갯수에 제약 없음

### 생성

```java
interface 이름{
    상수 선언
    추상 메서드 선언
    default method 생성
}
```

### 클래스에 구현

```java
class 클래스이름 extends 상위클래스 implements 인터페이스 나열{
클래스 내용
}
```

- 인터페이스에 추상 메서드가 있다면 클래스에 `반드시 구현`
  - 인터페이스를 implements 하게 되면 인터페이스의 메서드가  
    클래스에 `반드시 구현되어 있다 보장`

### 사용 이유

- `다형성 구현`
- 특정한 `메서드가 구현되어 있음을 보장`

### 인터페이스끼리 구현 기능

interface 이름 extends 인터페이스이름 나열{

}

### default method

- 인터페이스에 `내용이 있는 메서드` 만들 때  
  결과형 앞에 **default** 라는 키워드 추가 후 작성

### Template Method Pattern

- 내용을 구현하기 전에 `모양을 가진 인터페이스를 만들고`  
  그 `인터페이스를 implements 해서 구현`하는 디자인 패턴
- 인터페이스는 다른 사람과의 대화 수단

```

#### 일반적인 데이터베이스 연동 프로젝트 생성 시 만들어지는 5가지 내용

- View
  별도의 애플리케이션 이거나 Controller 에게 전달 받음
- Controller
- Service
  반드시 Template Method Patten 적용
- Repository
  TMP를 썼었으나 인터페이스만 만들면 프레임워크를 통해
  내부 구현이 가능해져 현재에는 잘 사용되지 않음
- DTO, VO, Entity 와 같은 데이터 표현 클래스
```

- 클래스를 `상속받는 클래스가 1개` 밖에 없는 경우  
  하위 클래스이름 은 상위클래스이름Ex 로 설정
- 인터페이스를 `구현하는 클래스가 1개` 밖에 없는 경우  
  클래스 이름은 인터페이스이름Impl 로 설정
- `하나의 인터페이스에 메서드가 여러 개 될 것 같으면 나누어 선언`
