---
title: ""
excerpt: ""

categories:
  - Blog
tags:
  - [
      Blog,
      kakaocloudschool,
      develop,
      javascript,
      oop,
      class,
      object,
      exception handling,
      module,
    ]

toc: true
toc_sticky: true

date: 2022-11-16
last_modified_at: 2022-11-16
---

### ...이어서 **늦음**

## 3. 모듈화

`모듈화는 중요한 작업 중의 하나`

> 하나의 모듈에 모든 내용을 전부 작성하면 가독성 하락, 재사용성 감소

- 역할별로 나누는 작업이 중요

- Controller  
  클라이언트의 요청을 받아서 필요한 서비스 로직을 호출하고 응답을 클라이언트에게 전송하는 역할

- MODEL

  - Service  
    사용자의 로직(Business Logic)을 처리하는 역할

  - Repository

    - DAO  
      Data Access Object
      - 데이터 저장소 와 연결해서 작업을 수행하는 역할

  - VO(Variable Object)  
    여러 개의 속성을 묶어서 하나로 표현하기 위한 역할
  - DTO(Data Transfer Object)  
    서로 다른 계층 사이에 전달을 위한 역할

  - Entity
    - ORM 에서 테이블 과 연결되는 역할
      - ORM  
        객체 와 테이블의 행을 매핑시켜주는 프레임워크

- View  
  화면 출력하는 역할

## 모듈의 내용을 내보내고 가져와서 사용

- 내용을 내보낼 파일 생성
- 해당 파일의 내용을 가져와서 사용할 파일 생성
- 실행할 파일을 생성

## Node 내장 객체

node 가 제공하는 객체

### 1. Global

노드의 전역 객체

- 노드 프로그램 전체에서 1개만 생성  
  하나만 만들어서 노드 프로그램 전체가 공유
  - 사용하는 것을 권장하지 않지만, 모든 곳에서 필요한 데이터일 때 사용
  - 현재 접속자 수 / 대기자 수 / 로고 등
  ```javascript
  global.변수명 = 사용하려는 변수명
  ```

### 2. Console

현재 보여지는 터미널 화면

- console.log(메시지)  
  메시지 로깅
- console.error(메시지)  
  에러 형태로 로깅
- console.trace(메시지)  
  호출 스택 로깅
  - 함수 나 메서드를 호출 순서 역순으로 출력
  - `호출 메서드의 순서 확인할 때 사용`
- console.table(배열)  
  테이블 형태로 출력
- console.time(메시지) & console.timeEnd(메시지)  
  동일한 메시지를 사용하면 2개 호출 사이의 시간 출력
- console.dir(객체, 옵션)  
  객체를 로깅할 때의 옵션 설정

  > 로직이 복잡해지거나 여러 모듈을 거칠경우 중간 로그 출력 확인 필요

### 3. 경로 관련 속성

- \_\_filename  
  현재 파일의 경로
- **\_\_dirname**  
   현재 디렉토리 경로

`최근 등장하는 언어와 프레임워크에는 _를 이용한 예약어가 많아`  
 `_를 활용한 사용자 정의 이름은 지양`

### 4. module.export

모듈의 내용을 다른 곳에서 사용할 수 있게 만드는 속성

```javascript
module.exports = 내보낼 내용;

exports.내보내려는 이름 = 내용;
```

### 5. this

> 함수 나 클래스 외부에서는 module.exports  
> 함수 안에서는 global  
> 클래스 메서드 안에서는 클래스의 인스턴스

### 6. require 함수

외부 모듈의 내용을 가져올 때 사용하는 함수

`import 와 달리 require 는 Caching을 한다`

- 한 번 사용한 모듈을 메모리에 적재했다가 다음 번 require에 캐싱된 모듈을 가져온다

### 7. process 객체

노드 프로세스에 대한 정보 객체

- 노드 버전이나 CPU 사용량 등 확인할 수 있는 속성과 메서드 제공
  - process.nextTick(콜백 함수)  
    다른 콜백 함수보다 우선해서 처리
    - Promise.resolve().then() 으로 작성 가능
  - process.exit(코드)  
    노드 프로세스 종료
    - 서버에서 사용하지 않는 것이 일반적  
      일반 애플리케이션을 만들었을 때 사용
    - (코드) 는 운영체제에게 알려주는 종료 이유

### 8. os 객체

운영체제에 대한 정보를 가진 객체

- 운영체제에 대한 종류 나 CPU, 메모리 사용량 등을 확인하는 속성과 메서드 제공
  `실 서비스에서는 메모리 사용량 확인 권고`

  ```javascript
  console.log(os.freemem());
  ```

  ***

### 9. path 객체 **잤음**

디렉토리 와 파일의 경로를 쉽게 조작하도록 도와는 모듈

- 속성 과 함수
  - path. sep  
    경로 구분자  
    서버 개발에는
  - path.dirname(경로)  
    **경로에 해당하는 파일이 위치하는 디렉토리**
  - path.extname  
    경로에 해당하는 파일의 학장자
  - path.join(경로를 나열)  
    경로를 합쳐서 하나의 경로로 리턴

### 10. url 모듈

url 과 관련된 모듈

- parse 함수  
  url 분해
- format 함수  
  분해된 url을 하나로 복원

### 11. searchParams 모듈

Query String 을 위한 모듈

- query string  
  **parameter**, 클라이언트가 서버에게 get 방식으로 요청 할 때 전송하는 데이터
- 읽어오는 함수
  - getAll(key)  
    key에 해당하는 모든 데이터를 가져오기
    - 체크 박스 나 파일의 경우 `다중 선택 가능`
  - get(key)  
    `key에 해당하는 데이터 1개만 가져오기`
    - 체크 박스 나 파일이 아니면 하나의 값만 전달
- 파라미터를 추가하는 함수
  - **append(키, 값)**  
    추가
  - **set(키, 값)**  
    수정

### 12. util 모듈

여러가지 편의 기능을 모아둔 모듈

- util.promisify  
  콜백 패턴을 Promise 패턴으로 변경

### 13. worker_thread 모듈

HTML5에서 추가된 Web Worker API를 사용하기 쉽게 해주는 모듈

- express 모듈로 웹 서버를 만들면 멀티 스레드 형식으로 사용자의 요청 처리
- Node 는 14버전 이후에 멀티 스레드를 지원

### 14. child_process 모듈

다른 프로세스(명령어)를 실행하는 모듈

- 운영체제 별로 분기를 해서 명령어 사용

## 암호화

crypto 모듈을 암호화에 이용

### 1. 암호화 방식

- 단방향 암호화  
  암호화는 가능하지만 `암호화된 문장(다이제스트)을 이용해 복호화 불가능`  
  원본 데이터 와의 **비교는 가능**

  - 동일한 문장 암호화하면 동일한 결과 나옴

  `해시 기법` 주로 이용

  - 문자열을 고정된 길이의 다른 문자열로 만드는 방식

  알고리즘

  - md5  
    취약점 발견
  - sha1  
    취약점 발견됐으나 안드로이드에서 가끔 사용
  - sha256
  - sha512  
    블록 체인에서 256에서 512로 변환 중

> 비밀번호 저장이나 블록 체인에서 주로 사용

```javascript
createHash(알고리즘)  //사용할 알고리즘 설정
update(문자열)   //변환할 문자열을 설정
digest(인코딩 방식) //인코딩할 알고리즘 설정
//base64를 주로 이용
```

- 양방향 암호화  
  암호화 할 때 `키를 사용해서 암호화`하는 방식으로 복호화 가능

  > 암호화 사용 키 와 복호화 사용 키 가 같아야만 복호화 가능

  `동일한 데이터를 암호화 했을 때 암호화된 결과가 다를 수 있음`

  - 비교 연산보다 **복원해서 재사용**

> 일반 데이터 암호화에 이용

```javascript
createCipheriv(알고리즘, 키, 초기화 벡터) //양방향 암호화 객체 생성
암호화객체.update(암호화 할 문자열, 문자열 인코딩 방식, 출력 인코딩 방식) //문자열 리턴
//문자열은 주로 utf-8
//출력은 주로 base-64
암호화객체.final(출력 인코딩 방식) //암호화 완료

createDeccipheriv(알고리즘, 키, 초기화 벡터) //양방향 복호화 객체
//암호화 할 때 사용한 것과 양식은 동일하나
//인코딩 방식 반대로 적용
복호화객체.update(복호화 문자열, 문자열 인코딩 방식, 출력 인코딩 방식)
복호화객체.final(출력 인코딩 방식)
```

`가장 중요한건 알고리즘, 키, 초기화 벡터에 대하여 `**따로 저장**`이 필요`

## 파일 시스템

파일 읽고 쓰기

- 파일을 읽고 쓰기 위한 모듈은 fs

### 1. 파일 읽기

```javascript
fs.readFile("파일 경로", [options], 콜백 함수) //비동기 방식
```

- 콜백 함수, 매개변수 2개
  - 첫 번째 매개변수
    에러가 발생했을 때 에러 내용
  - 두 번째 매개변수  
    읽기에 성공했을 때 읽어내는 데이터

```javascript
fs.readFileSync("파일 경로", [options]); // 동기식 방식
```

`동기식에는 콜백이 불필요`

### 2. Buffer

데이터를 저장하기 위한 메모리

- 버퍼링  
  데이터를 한꺼번에 처리하기 위해서 데이터를 모으는 작업

> readFile 이라는 함수는 읽어내고 난 후 Buffer 객체를 리턴

- Buffer 객체
  - length  
    크기
  - from  
    문자열을 Buffer 로 변경
  - toString  
    Buffer 의 내용을 문자열로 변환

### 3. 파일 읽는 방식

`변경 가능하거나 변하지 않는 중요한 문자열`  
파일이나 데이터베이스에 저장하고 읽는 방식 사용

- 운영 환경 과 개발 환경이 다른 경우  
  소스 코드를 수정하게 되면 컴파일 과 빌드를 다시 해야 함
  ```javascript
  let databaseURL = "172.16.30.30"
  ///수정 사항에 대해서 컴파일 과 빌드를 다시 해야 함
  //소스코드를 수정했기 때문
  파일에 기록 > 소스 코드에서는 파일의 내용 읽기
  //특정 파일이 되기 때문에 다시 실행만 하면 됌
  ```
- 클라이언트에 배포하는 프로그램을 만든 경우  
  대부분의 언어는 역 어셈블이 가능
  - 실행이 되는 코드에서 소스 코드를 찾아가는 과정

### 4. 동기식 파일 읽기

### 5. 비동기식 파일 읽기

파일 읽는 도중 다른 작업을 수행할 수 있도록 한 것

### 6. Stream

데이터의 흐름  
`데이터를 일정한 크기로 잘라서 여러 번에 나누어서 처리`

- 용량이 큰 파일을 한 번에 읽으면 버퍼 크기가 커져 메모리 부담
  - chunk  
    작게 잘라서 처리
    ##### 로그 파일 읽을 때
- 스트리밍  
  일정한 크기의 데이터를 지속적으로 전달하는 작업

  ```javascript
  fs 모듈의 createReadStream | createWriteStream 이용
    파일 경로 와 highWaterMARK 옵션을 이용해 버퍼 크기 설정

  읽기 스트림의 경우
  data(하나의 버퍼를 읽음), end(읽기 끝), error(오류) 이벤트 처리

  쓰기 스트림의 경우
  drain(하나의 버퍼 씀), finish(쓰기 끝), error(오류) 이벤트 처리
  ```

### 7. Stream 을 사용하는 이유

스트림을 사용하지 않고 복사

- 기존 메모리에 파일 크기 만큼의 메모리 추가 필요

스트림을 사용하고 복사

- 파일의 내용을 잘라서 읽기 때문에 파일의 크기 만큼의 메모리 추가 불필요

### 8. 기타 함수

- access(경로, 옵션, 콜백)  
  디렉토리나 파일에 접근할 수 있는지 확인
  - 접근 불가 시 에러
- mkdir(경로, 콜백)  
  경로를 생성
  - 신규 유저 정보 저장 폴더 등
    > 이름으로 생성 / 날짜 삽입 / UUID 생성
- open(경로, 옵션, 콜백)  
  경로의 파일을 열고 아이디를 리턴하는데 파일이 없으면 생성
- rename(기존 경로, 새 경로, 콜백)  
  이름 변경
- unlink(경로 콜백)  
  파일 지우기
- rmdir(경로, 콜백)  
  디렉토리 삭제

`콜백은 에러 객체를 넘겨 받기에 에러 객체 유무로 에러를 알 수 있음`

## ThreadPool

pool  
만들어서 모아 놓은 것으로 `주로 서버에서 사용`

      Server
    요청을 처리하고 응답을 전송하는 쪽
      속도 나 효율 을 중요시
      자주 사용되는 것들은 미리 만들어두고 사용 바로 할 수 있어야 함

      Client
    요청을 전송하고 응답을 출력하는 쪽
      신뢰성 이나 가용성 을 중요시
      메모리 효율을 높여야 하기 때문에 사용하기 직전에 만드는 것을 권장

- Thread(**작업 도중 다른 작업을 할 수 있도록 하는 작업의 단위**)  
  를 미리 만들어서 모아놓은 것
  - **독자적으로 실행이 가능한 단위**는 Process
    - `Thread 는 Process 안에 존재하는 실행 단위`
- 몇몇 작업에 한해서는 ThreadPool을 이용해서 처리
  - fs  
    파일 입출력 모듈
  - crypto  
    암호화 모듈
  - zlib
  - dns
  - lookup
    > 비동기 나 스레드 형태로 처리를 하는 작업들은 일반적으로 시간 오래 소요
    - 기본적으로 4개의 스레드를 만들고 활용
    - 파일을 비동기적으로 읽거나 암호화 하게 되면 순서대로 처리 X

## 노드에서 이벤트 처리

1. 이벤트 연결

```javascript
객체.addEventListener("이벤트 이름", 함수);
객체.on("이벤트 이름", 함수);

객체.once("이벤트 이름", 함수); //이벤트 최초 발생 시에만 수행
```

2. 이벤트 삭제

```javascript
객체.removeEventListener("이벤트 이름", 함수); //함수만 제거
객체.removeAllEventListener("이벤트 이름"); //모든 함수가 제거
```

3. 이벤트 강제 발생

```javascript
객체.emit("이벤트 이름");
```

4. 이벤트에 10개 이상의 함수를 연결 할 경우

```javascript
// 기본적으로 에러
객체.setMaxListeners(개수); //개수만큼 연결 가능
```

## 예외처리

예외가 발생하게 되면 프로그램은 중단

> 서버는 아주 위험한 예외가 아니라면 프로그램 중단되면 안 됌

- 서버 프로그래밍에서는 대다수의 코드를 예외 처리 구문 안에 삽입
- 예외 발생 시, 예외 기록하고 계속 작업 수행
  ```javascript
  try{
    예외 발생 가능성 코드
  }catch(예외 객체){
    예외 발생 수행할 내용
  }finally{
    예외 발생 여부 상관없이 수행
  }
  // catch 와 finally 중 하나는 생략 가능
  ```
  `학습할 때와는 달리 실무에서는 예외를 기록하고 알림`

### 1. 예외 처리의 목적

- 예외가 발생하더라도 계속 동작
- 예외를 로깅하기 위해서

### 2. 예외 객체의 멤버

- name  
  예외 이름
- message  
  예외에 대한 설명

### 3. 강제 예외 발생

```javascript
throw new Error("예외 메시지");
```

### 4. 노드에서 예외가 발생해도 예외 처리 하지 않아도 되는 경우

콜백 함수의 매개변수가 예외 객체인 경우 예외 처리 불필요

- 예외처리 구문으로 감싸져 있고, 예외 객체를 넘겨줌
  - 존재여부만 파악해서 작업만 지정하면 됌

## 자주 발생하는 에러

- 터미널 명령 입력
  command not found 에러

  - 명령어 오입력
  - 명령어 없음
  - 명령어가 있는 곳을 path 환경 변수에 설정 안한 경우

- 코드를 작성한 후 실행 시 모듈이름 is not defined

  - 모듈을 가져오지 않음
  - 모듈 이름을 잘못 기재

- 실행을 하다가 EADDRINUSE

  - 이미 포트 사용 중으로  
    포트를 사용 중인 프로세스를 종료하고 수행

    ```javascript
    // 프로세스 종료
    Windows: taskkill /pid 프로세스아이디 /f
    //그 이외
    kill -9 프로세스아이디

    // 포트를 사용 중인 프로세스 찾기
    Windows: netstat -ano | findstr 포트번호
    //그 이외
    lsof -l tcp:포트번호
    ```
