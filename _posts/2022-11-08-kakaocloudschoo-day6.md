---
title: "Function과 Class, 객체 지향의 정의"
excerpt: "사용자 함수, 내장 함수에 대하여 학습하고,
객체 지향의 이론적 의미와 사용자 정의 객체와 class를 학습한다"

categories:
  - Blog
tags:
  - [Blog, kakaocloudschool, develop, javascript, oop, function, class]

toc: true
toc_sticky: true

date: 2022-11-08
last_modified_at: 2022-11-14
---

# 사용자 정의 Function

코드를 하나의 이름으로 묶어두고 사용

- Argument(Parameter, 매개변수, 인자, 인수)  
  함수가 호출할 때 호출하는 쪽에서 넘겨주는 데이터

  - 파라미터가 없다면 동일한 작업만 수행

  ```javascript
  var 함수 이름 = function(매개변수 나열){
  		  함수 작업
  		  }

  함수이름(매개변수);//함수 호출
  ```

  - 매개변수는 상황에 따라 없거나 여러 개 일 수 있음  
     매개변수는 함수 내의 지역 변수로, **함수 외부에서 사용 불가**

    - (call by value)  
       매개변수에 `하나의 데이터를 저장하는 기본형 데이터`를 대입하면
      함수 내에서 데이터를 변경해도 `원본에는 아무런 영향이 없음`
    - (call by reference)  
       `0개 이상의 데이터를 가진 배열이나 객체를 대입`한 경우
      함수 내에서 배열이나 객체의 내부 요소를 변경하면
      `원본도 변경`

  - arguments 배열  
    `함수 내의 만들어진 숨겨진 변수`
    - 매개변수에 데이터를 대입하면 순서대로 저장하고 있는 배열 - 매개변수 개수보다 더 많은 양의 데이터를 대입  
      매개변수 갯수만큼 대입하고 나머지는 arguments 배열에서 찾아서 사용
      - 매개변수 갯수보다 적게 대입  
        앞에서부터 채워지고 **나머지는 undefined**

- return  
   함수의 수행을 종료, 하나의 데이터를 호출한 곳으로 넘겨줄 때 사용
  - return 뒤에 문장은 수행되지 않음
- pure function(순수 함수)  
   `동일한 입력에 대해 항상 동일한 출력`

  - 외부 데이터 변경 x
  - 결과는 리턴을 통해서

- recursion(recursive call)
  `함수가 자기 자신의 함수를 리턴`  
  재귀를 사용하면 **코드의 가독성 향상**되나  
  **메모리 사용량 증가**되고 **소요 시간 증가**  
  재귀를 만들 떄는 반드시 **종료하는 지점**이 필요

- 일급 객체
  함수도 하나의 일급 객체  
  `함수도 하나의 자료형이므로 변수 대입, 매개변수 사용, return 가능`
  - Callback  
    이벤트나 상태 변화가 발생할 때 호출하는 함수
    - 함수의 매개변수로 함수를 대입받는 형태로 구현
  - nested 함수  
    함수 안에 함수를 만드는 것
  - high order function  
    다른 함수를 리턴하는 함수
    - currying이라고도 하며, `디자인 패턴으로 간주`하기도 함
- closuer  
  함수 안에서 함수를 리턴해서 `함수 외부에서 함수 내부의 데이터 수정`
- 함수의 매개변수에 기본값 설정이 가능  
  `매개변수 뒤에 = 와 함께 값을 설정하면 가능`
- 화살표 함수  
  ecma2015 추가
  ```
  (매개변수 나열) => {
  함수 내용
  }
  ```
  - 매개변수가 한개라면 괄호는 생략 가능
  - 함수의 내용이 한 줄이면 중괄호도 생략 가능
  - 마지막 수행되는 문장의 결과가 return
  - **함수 내부에서 this와 arguments 사용 불가**
  - arguments 대신에 rest를 사용
    - 앞에서 줄 바꿈하면 에러이고, 뒤에는 무관
    - 콜백 함수 설정 시 주로 이용

# Built in function

- `js에서 제공하는 함수`로, `실제로는 window 객체의 메서드`

  - window 객체를 이용해 내부 요소 호출할 때는  
    window. 이 생략 가능하여 전역함수처럼 사용

1.  alert  
     메시지를 대화상자에 출력

- alert(메시지)  
  return은 없음

2.  confirm  
     메시지를 대화상자에 출력, 버튼 2개 제공  
     확인은 true, 취소는 false
3.  prompt  
     한 줄의 문자열 입력 대화상자

- prompt(메시지, 기본값)
- 확인을 누르면 입력 문자열 return, 취소를 누르면 null

4.  eval  
     문자열 대입시 이에 해당하는 dom 객체 return

`최근에는 document.getElementByID 권장`

5. 인코딩  
   데이터를 컴퓨터에 저장하는 형태

- 자바스크립트에서 서버 데이터 전송하고 GET 방식 사용
- query string(params)
  - query에 한글이 포함되어 있는데 인코딩하지 않고 전송하면 글자가 깨져 반드시 인코딩 필수
- escape(문자열)  
  일부 특수문자(@,\*,-...)를 제외한 모든 문자 인코딩
- **encodeURL(문자열)**  
  인터넷 주소에 사용되는 문제 제외 인코딩
- encodeURIComponenet(문자열)  
  알파벳과 숫자를 제외한 모든 인코딩

6. 디코딩  
   컴퓨터에 저장된 데이터를 출력하기 위한 형태로 만드는 것

- unescape
- decodeURI
- decodeURILComponent

7. isNaN  
   nan 여부를 판단하는 함수
8. isFinite  
   유한수 판단
9. parseInt / parseFloat  
   문자열 정수/실수 변환 함수

- 숫자에서 문자열 변환은 new String(숫자 데이터)
  ```
  숫자 + " "
  ```

# javacript의 OOP

es5까지는 클래스의 개념이 없어서 oop의 개념이 아님

- 객체 기반 언어

ecma 2015에서 클래스의 개념이 도입됨

## 객체 지향의 3대 특징

1. 캡술화(Encapsulation)  
   `불필요한 부분을 숨기고 하나로 만드는 것`

- 클래스 만들기
- 인스턴스 만들기
- 접근 지정자

2. 상속(Inheritance)  
   하위 클래스가 상위 클래스의 모든 것을 물려받는 것
3. 다형성(Polymorphsim)  
   동일한 메시지에 대하여 다르게 반응하는 성질  
   `동일한 코드가 호출하는 객체에 따라 다른 메서드 호출`
   - 상속 과 오버라이딩(가끔은 구현) 구현

## 객체(Object)

데이터를 저장할 수 있는 속성(variable -> property)  
기능을 수행하는 메서드(function -> method)

- (소속이 있을 경우 이렇게 지칭)

1. 사용자 정의 객체  
   개발자 필요에 의해 생성
2. 내장 객체  
   js에서 제공하는 객체

- API(application programming interface)
- SDK(software development kit)

3. 3rd Party 객체  
   다른 개발자나 회사가 제공

- 라이브러리
- 프레임워크
- 솔루션(특수한 목적을 가진 프레임워크)

# 사용자 정의 객체

1. 생성

   ```javascript
   var | let | const 이름 = {
   	"속성이름":데이터,
   	"메서드이름":메서드코드 ...
   	}
   var | let | const 이름 = new 생성자(매개변수 나열)
   ```

2. 내부 요소 호출

   ```javascript
   이름.속성이름;
   이름.메서드이름(매개변수);
   //. 대신에 [속성이름] 가능하나, 속성이름은 문자열 형태
   ```

`내부 속성은 중복 생성 되지 않아 같은 이름 2번 만들면 새로운 내용으로 변경`

3. for in
   ```javascript
   for(임시변수 in 객체){
   수행 내용
   }
   ```
   `객체의 모든 속성 이름을 임시변수에 문자열 형태로 대입 후 내용 수행`
4. 속성이름 in 객체  
   속성이 객체에 존재하는지 여부를 판단해서 boolean으로 리턴
5. with 블럭
   ```javascript
   with(객체이름){
   객체 이름 생략 가능
   }
   ```
6. 속성 추가 및 수정
   ```
   객체이름.속성이름 = 데이터 또는 함수;
   ```
   - 존재하는 속성이면 수정이고 아니면 추가
7. 속성 삭제
   ```
   delete(객체이름.속성이름)
   ```
8. **this**  
   객체 안에 존재하는 메서드에 존재하는 숨겨진 매개변수

- 객체 안에 만들어진 메서드에서 변수로 사용할 수 있으며 객체를 참조

  - 객체 안에 만들어진 메서드에서 객체의 속성을 이용할 때는 this.속성이름
  - this. 없으면 사용 메서드 안에서 찾음

  `화살표 함수에서 사용 불가`

9. constructor(생성자)  
   `객체를 생성해서 메모리 할당을 하고 그 참조를 리턴하는 함수`

- 일반 함수를 만드는 것과 동일하나  
  `객체 생성하려면 `**내부에서 this를 이용해**` 필요한 속성과 메서드 정의`
  - 생성자 호출  
    new 생성자 이름(매개변수)
    - `동일한 속성을 갖는 객체 여러개 생성 할 때 생성자 필요`
  - 유니크한 속성이 하나는 있어야 하고  
    배열이 하나 이상이면 효율적이지 못함

# class

유사한 모양의 객체를 만들기 위한 템플릿

- 모든 멤버를 생성자 안에서 만들어야 하기 때문에
  객체의 메서드가 많아지면 가독성이 떨어져 es6에서 추가

  ```javascript
  class 클래스 이름 { //기본적인 방법
  내용
  }
  class 클래스 이름 extends 상위 클래스 { //상속받을 때
  내용
  }
  let 이름 = class{ //표현식
  내용
  }
  let 이름 = class 내부에서 사용할 이름{
  내용
  }
  ```

  - 클래스 이름은 일반적으로 대문자로 시작

- 클래스를 이용한 객체 생성  
  클래스를 이용해서 생성된 객체를 **instance**

  - 객체기는 한데 구빈이 되느냐
  - 어느 영역에 저정되느냐

  `클래스의 생성자는 클래스 이름과 동일하게 만들어지므로 생성자 이름 대신에 클래스 이름 기재 가능`

  ```
  let | const 이름 = new 생성자이름(매개변수);
  ```

  - new 연산자는 생성자를 호출 인스턴스를 heap 영역에 만들고 참조 리턴

- 클래스 안에 멤버 속성 만들기

  - 메서드 안에서 **this와 함께 이름을 만들면 인스턴스의 속성**이 된다

- js에서의 class는 정적이지 않다  
  `js에서는 class의 내용이 수정 가능`

  - prototype이라는 내부 객체를 이용해서 모든 속성 저장
    - prototype 역시 객체라서 확장이 가능
    ```javascript
    //클래스 선언 이후에 추가, 변경이 필요할 경우
    클래스이름.prototype.속성이름 = 내용;
    ```

- 이름
  - `js에서는 변수, 값, 함수, class가 모두 동일한 레벨`
    - 기존의 이름에 값이 저장되어 있을 때,  
      함수 대입하면 기존 값 사라지고 함수의 내용이 저장
