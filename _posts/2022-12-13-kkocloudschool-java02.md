---
title: "Java 이론에 대한 학습"
excerpt: "Java의 출력에 대해 학습하고,
Java의 자료형에 대해 학습하고,
Java의 연산자에 대해 학습한다"

categories:
  - Blog
tags:
  - [Blog, kakaocloudschool, develop, java]

toc: true
toc_sticky: true

date: 2022-12-13
last_modified_at: 2022-12-13
---

## Console 출력하는 메서드

```java
System.out.print(String msg) // 메시지 출력 후 다음 메시지 이어서 출력
System.out.println(String msg) // 메시지 출력 후 다음 메시지 줄 바꿈
System.out.printf(String format,... data) // format 에 맞춰서 데이터 출력
```

- 출력 메서드에 객체 참조를 대입하면 `toString 메서드 호출한 결과와 동일`
  - 기본적으로 자신의 클래스 이름과 해시코드의 결합이되  
    이외의 내용이 나오는 건 Overriding 해서 내용 수정

# Data type

## 1. Data 의 분류

### `변경 가능 여부`에 따른 분류

- Immutable(read only) Data  
  생성하면 수정할 수 없는 데이터
  - Literal  
    프로그래밍 언어가 데이터를 표현하기 위해 정해준 방식  
    직접 입력하는 데이터
  - Constant  
    개발자가 의도적으로 읽기 전용으로 만든 데이터
    ```java
    final DataType 이름 = 초기값;
    ```
- Mutable Data  
  생성한 후 상황에 따라 다른 데이터의 참조를 저장할 수 있는 데이터
  - Varaible
    ```java
    DataType 이름;
    DataType 이름 = 초기값;
    ```

### `저장되는 데이터 종류`에 따른 분류

- Value Type  
  실제 데이터를 저장하는 타입

- Reference Type  
  데이터의 참조(address 나 hash code)를 저장하는 타입

### `저장되는 데이터의 개수`에 따른 분류

- Scala Type  
  하나의 데이터만 저장하는 자료형으로 Primitive Type
- Collection(Vector) Type  
  0개 이상의 데이터를 저장하는 자료형으로 Primitive Type 제외한 나머지

### `Data Type 기재 방법`에 따른 분류

- Static Type  
  변수 나 상수를 선언할 때 자료형을 결정해야 하는 Type

  - C, Java 는 Static Type 언어
  - 소스 코드 작성 단계에서 타입 불일치와 같은 오류 검출 가능
    - Kotlin, Switf 등은 Dynamic 처럼 선언하지만 Static
  - Template 프로그래밍으로 인스턴스 생성 시 Data Type 결정 지원
    - Generic 기능

- Dynamic Type  
  변수 나 상수를 선언시 자료형을 기재하지 않고 데이터의 참조 대입 시 결정
  - JavaScript 와 Python 이 Dynamic Type 언어

### 최근에는 정형, 비정형, 반정형으로 나누기도 하고

### NULL 저장 가능한(Optional) 자료형 과 NULL 이 저장되지 않는 자료형

## 2. Java의 자료형

### 자료형의 분류

- Primitive Type(기본형)  
  하나의 데이터를 저장하기 위한 자료형
- NonPrimitive Type  
  0개 이상의 데이터를 대표하는 참조를 저장하기 위한 자료형

### 생성

```java
자료형 식별자이름;
자료형 식별자이름 = 초기 데이터;
```

### 사용

- 식별자 이름을 이용해서 데이터에 접근
- **Primitive** 타입은 이름 자체가 데이터  
  **NonPrimitive** 타입은 이름이 데이터를 `대표하는 위치`
- 초기값을 설정하지 않으면 `초기값 설정만 가능`하고  
  다른 용도로 사용시 에러 발생

### 명명 규칙

- **Camel Case**

  - 클래스 나 인터페이스 이름은 대문자로 시작
  - 속성 과 메서드 이름은 소문자로 시작
  - 두 개 단어 이상의 조합일 때 두번째 단어는 대문자

- **Snake Case**  
  상수의 이름은 모두 대문자로 표현
  - 첫글자는 영문 이나 한글 그리고 $ 와 \_ 가능
  - 한글은 가능하나 인코딩 문제로 잘 쓰지 않음
  - 중간에 공백 불가능

### `변수 나 상수의 유효 범위`에 따른 분류

- **Local Variable**  
  `메서드 안에서 만들어진 변수`로 데이터 저장 공간이 `Stack`  
  메서드 안에서만 사용 가능하고 `작업 종료시 메모리와 함께 소멸`
  - 자신이 만들어진 블럭 안에서만 사용 가능
- **Member(Instance) Variable**  
  `클래스 안 그리고 메서드 바깥에 static 이라는 keyword 없이 생성`  
  데이터의 저장 공간은 `Heap 에 생성`되고 `인스턴스로만 접근` 가능  
  인스턴스가 소멸되면 같이 소멸  
  `인스턴스는 자신을 참조하는 데이터가 없으면 메모리 정리 대상이 됨`
- **Static Varible**  
  클래스 안 그리고 메서드 바깥에 `static 이라는 keyword와 함께 생성`  
  데이터의 저장 공간은 `Class(Static) 영역`이 되고 클래스로 접근 가능

  - 자바에서는 인스턴스로도 접근 가능

  클래스는 한 번 로드되면 메모리에서 소멸되지 않아 앱 종료시까지 남음

### 자바의 기본 자료형

- **boolean**  
  true 아니면 false 만 저장 가능한 자료형  
  다른 자료형과 호환이 되지 않음

정수 자료형

- **byte**  
  1byte, -128 ~ 127 까지 저장 가능
- **short**  
  2byte, -32768 ~ 32767 까지 저장 가능
- **char**
  2byte, 0 ~ 65535 까지 저장 가능  
  저장을 할 때는 정수로 저장하고 출력을 할 때는 문자로 출력
- **int**  
  4byte, 21억 정도의 음수 와 양수 저장 가능  
  정수 리터럴의 기준형
- **long**  
  8byte

> 정수 리터럴은 그냥 숫자만 사용하면 10진 정수로 판단하고 int  
> 정수 뒤에 L을 붙이면 long 형 리터럴이 된다  
> byte, short, car, int, long 은 `표현 범위보다 큰 데이터 저장 불가`  
> long 형 리터럴은 long 에만 저장 가능  
> 천단위 구분기호는 \_  
> `정수 앞에 0`을 붙이면 8진수로 주의  
> `정수 앞에 0x` 를 붙이면 16진수

실수 자료형

- **float**  
  4byte, 10의 38 승 정도 저장 가능  
  정밀도는 소수 7자리
- **double**  
  8byte, 10의 308 승 정도 저장 가능  
  정밀도는 소수 15자리 정도  
  실수 리터럴의 기준형

> float 형 리터럴을 만들 때는 뒤에 f 작성  
> double 형 리터럴을 만들 때는 뒤에 d 작성이 선택  
> 실제 저장시 부동 소수점 형태로 저장되어 `부호가수지수 형태로 작성 가능`
> // 31.4 => +0.314E(e)001  
> 현재는 CPU 안에 수치 연산 보조 프로세서가 있어 double 단위 연산 수행

- **문자 저장**  
  문자 리터럴은 '' 안에 하나의 문자를 기재  
  자바는 유니코드 사용으로 char 가 2byte  
  문자에 해당하는 정소 코드로 작성 가능

  - 0은 48  
    A는 65  
    a는 97

  문자는 모든 경우에 정수로 취급하고 `출력 시 문자 취급`  
   대입할 땐 \ 다음에 8진수 3자리 대입하거나, \u 다음에 16진수 4자리

  - 'A'+ 1 은 66

- **제어문자**  
  \ 다음에 하나의 문자를 추가해서 특별한 기능을 갖도록 한 문자
  - \n  
    개행
  - \t  
    탭
  - \\  
    \ 출력
  - \\', \\"  
    ', " 출력
  - \0  
    null

### Overflow 와 Underflow

- **Overflow**  
  표현 범위를 위쪽으로 넘어선 경우로  
  앞쪽의 데이터를 잘라 넘어가면 가장 작은 숫자부터 다시 시작
- **Underflow**  
  표현 범위를 아래쪽으로 넘어선 경우로  
  앞쪽의 데이터를 잘라 넘어가면 가장 큰 숫자부터 다시 시작

### boolean 데이터

- true 아니면 false 만 저장
- Java API 메서드 중에서 이름이 is 로 시작하면 return 은 boolean

  - boolean 으로 변수 생성 시 앞에 is를 붙이는 것이 일반적

- 이 자료형은 `문자열로 변환`하거나, `문자열을 이 자료형으로 변환`하는 것만 호환

### String

- 0개 이상의 문자열을 저장할 때 사용할 수 있는 클래스
- 기본형은 아니지만 기본형 처럼 사용
- `인스턴스를 생성`할 때 리터럴을 이용할 수 있음
- 문자열 리터럴은 " " 안에 작성

  ```java
  String 이름 = "문자열";
  ```

- **toString 메서드**는 저장하고 있는 문자열을 리턴하도록 만들어져 바로 출력 가능

### 서식을 이용한 데이터 출력

- `System.out.printf 이용`
- 첫번째 매개변수로 문자열 형태로 서식을 설정

  - 서식을 설정할 때는 % 와 포맷문자를 조합

- 두번째 매개변수 부터는 앞의 서식 문자와 매핑되는 데이터 나열
- 서식 문자

  - %d  
    10 진수
  - %x  
    16진수
  - %o  
    8진수
  - %i  
    10진수
  - %f  
    실수
  - %e  
    지수 형태로 출력
  - %c  
    하나의 문자
  - %b  
    boolean
  - %s  
    문자열

- 서식 문자 앞에 `숫자를 추가해서 자릿수 확보` 가능
  - %10d  
    10자리 확보해서 출력
  - %010d  
    10자리 확보해서 출력하고 남는 자리 0
  - %전체자리수.소수자릿수f  
    전체 자리를 확보하고 소수 자릿수만큼 소수를 출력(반올림)
    - 전체자릿수 생략하고 .소수자릿수 형태로 설정 가능
  - 정수 부분은 실제 데이터의 길이보다 적게 설정해도 잘리지 않음

## 3. 연산자

### 1. 연산의 분류

- `연산의 결과 또는 연산될 때 데이터`에 따른 분류
  - **Arithmetic Operation**(산술 연산)  
    숫자 데이터의 연산
  - **Logical Operation**(논리 연산)  
    boolean 데이터의 연산
- `피연산자의 개수`에 따른 분류

  - **Unary**  
    데이터가 1개이면 수행되는 연산
  - **Binary**  
    데이터가 2개이면 수행되는 연산
  - **Ternary**  
    데이터가 3개이면 수행되는 연산

- 용도에 따른 연산 및 우선 순위
  - ( ), [ ], { }  
    최우선 연산자
  - ++, --, 부호 +, 부호 -, (자료형), !, ~  
    단항 연산자
  - %, /, \*, +, -  
    이항 산술 연산자
  - \>>, <<, \>>>  
    shift 연산자(이항 산술)
  - <, <=, >, >=, instance of, ==, !=  
    논리 연산자
    - instance of 는 인스턴스 와 클래스
  - &, ^ |  
    정수 데이터를 가지고 2진수의 비트 단위로 연산해 정수 데이터 리턴
  - &&, ||  
    boolean 데이터를 가지고 연산 수행 후 boolean 리턴
  - ? : :  
    삼항 연산자
  - =, 연산자=  
    할당 연산자

### 2. 최우선 연산자

- ( )  
  `연산의 우선 순위 변경`을 위해 사용하는 연산자
- \[ ] , { }  
   [ ] 는 `배열의 크기 나 인덱스 설정` 시 사용  
   { } 는 `배열을 생성`할 때 사용
- ~ 연산자  
  `1의 보수`를 구해주는 연산자  
  정수 데이터의 `모든 비트를 반전`하는 연산자

  - 양수에 붙이면 부호는 음수, `절대값은 1 증가`
  - 음수에 붙이면 부호는 양수, `절대값은 1 감소`
  - `비트 반전(색상 반전 등)`에 사용

- ! 연산자  
  boolean 데이터만 사용 가능한데, 데이터 반전

- 부호 +, -  
  \+ 는 대부분 생략하고, - 는 음수로 보는데 `실제로는 2의 보수` 구해줌
- 증감 연산자  
   ++ 와 --  
   정수 변수 데이터에만 사용  
   변수의 데이터를 1 증가시키거나 감소 시키는 연산자  
   데이터 앞(prefix) 나 뒤(postfix) 모두에 사용 가능
  - `앞에 사용`되면 변수의 값을 먼저 증감
  - `
`되면 나중에 증감

### 3. 산술 연산자

- %  
  정수 데이터를 가지고 나머지를 구해주는 연산자
- /, \*, -, +  
  숫자 데이터를 가지고 사칙 연산을 수행

Java에서는 `산술 연산의 최소 단위가 int`  
 byte, short, char 는 int 로 변환되서 산술 연산을 수행하고 int 결과 리턴  
 2개의 서로 다른 숫자 자료형끼리 연산을 하면 `큰 자료형으로 변환`해  
 연산 수행하고 결과도 `큰 자료형으로 리턴`

- byte < short/char < int < long < float < double

데이터 입력 도중 한 글자 오류가 나는 걸 transcription error  
방지를 위해, 데이터 몇 개를 추가해 특정한 숫자로 나누었을 때 나머지 0이 되게

- 주민등록번호 나 신용카드 번호, 계좌번호 가 이 원리
- 숫자 3자리 구분에는 1개를 추가해 4자리로 구성을 하고  
  3자리는 직접 작성, 1자리는 연산으로 결정
  - mod10

## 4. Type Casting(자료형 반환)

데이터의 자료형을 변경하는 것

### 종류

- **자동 형 변환**  
  묵시적으로 이루어지는 형 변환  
  산술 연산에 int 보다 작은 숫자 자료형을 사용한 경우 int로 자동 형 변환  
  서로 다른 자료형끼리 연산 수행하면 더 큰 자료형으로 자동 형 변환 후 수행
- **강제 형 변환**  
  명시적으로 형 변환을 수행  
  (자료형이름)데이터

  - 데어터의 자료형이 ( ) 안의 자료형으로 변환

  `숫자 데이터끼리` 강제 형 변환이 가능  
  `인스턴스끼리는 상속 관계`인 경우만 가능

  - 숫자 데이터와 문자 데이터끼리는 안되지만 메서드 제공

  `문자열을 숫자 데이터로 변환`할 때는 Wrapper 클래스 이용

  - 숫자 데이터를 문자로 변경할 때는 String 메서드, 빈 문자열과 + 연산

  강제 형 변환은 원하는 결과를 만들 때 사용  
   실수를 정수로 강제 형 변환시 소수 부분 사라짐

  - 큰 자료형에서 작은 자료로 형 변환 시 데이터 손실 발생

- `언어마다 숫자를 다루는 방식이 다르므로 숫자 연산 전에 확인`

## 5. shift 연산자

- 정수 데이터에만 사용 가능
- 2진수를 가지고 비트 단위로 밀어내는 연산자  
  **<<**  
  첫번째 비트를 제외하고 나머지 비트를 왼쪽에서 제거하고 뒤에 0 삽입  
  부호가 변경되지 않음  
  **\>>**  
  뒤에서 밀어내는데 맨 앞에 추가되는 비트는 첫 번째 비트로 계속 추가  
  부호가 변경되지 않음  
  **\>>>**  
  맨 앞에 0을 추가하면서 밀어내는 연산자  
  음수를 가지고 수행하게 되면 양수가 만들어짐

- 32번 이상 밀어낼 경우 32로 나눈 나머지만 밀어내어  
  `32번 이상 shift 하지 않음`

## 6. 크기 비교 연산자

### >, >=, <, <=

- 숫자 데이터에만 사용할 수 있고 결과는 boolean

### 동일성 여부

- ==  
  해시 코드를 비교해서 일치하면 true
- !=  
  해시 코드를 비교해서 일치하지 않으면 true

`동일성 비교 할 경우 equals( ) 메서드 재정의 하여 사용`

### instance of

어떤 인스턴스가 `클래스의 인스턴스인지 확인`하는 연산자

- 클래스는 상위 클래스이면 된다
- Generic 이 적용되는 경우에 주료 사용
  - 대입되는 데이터가 특정 클래스 타입인지 확인할 때

## 7. 논리 연산자

- &&  
  boolean 데이터에만 적용이 가능한데 둘 다 true 일 때만 true
  - 우선 순위가 높음
  - `앞의 결과가 false 면 뒤의 결과 확인하지 않음`
- ||  
  boolean 데이터만 적용 가능한데 둘 다 false 일 때만 false
  - `앞의 결과가 true 이면 뒤의 결과 확인하지 않음`

`boolean 데이터 이외는 boolean 으로 간주하지 않음`
