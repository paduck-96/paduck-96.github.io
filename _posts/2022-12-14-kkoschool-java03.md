---
title: "반응형 웹, 자바스크립트의 문법 일부"
excerpt: "반응형 웹에 어울리는 flex와 grid. 자바스크립트에 대한 설명과 기본 문법까지..."

categories:
  - Blog
tags:
  - [Blog, kakaocloudschool, develop, responsive web, javascript]

toc: true
toc_sticky: true

date: 2022-12-14
last_modified_at: 2022-12-14
---

...

## 7. 논리 연산자

### 비트 논리 연산자

정수 데이터를 가지고 연산을 수행하는데 비트 단위로 논리 연산을 수행한 후 정수로 결과를 리턴

- ~  
  단항 연산자로 `1의 보수를 리턴`하는 연산자
- &  
  and 연산자로 둘 다 1인 경우만 1
- |  
  or 연산자로 둘 다 0인 경우만 0
- ^  
  eXclusive OR로 같으면 0 다르면 1

        20: 00000000 00000000 00000000 00010100
        17: 00000000 00000000 00000000 00010001

        20 & 17: 00000000 00000000 00000000 00010000 => 16
        20 | 17:   00000000 00000000 00000000 00010101 => 21
        20 ^ 17:  00000000 00000000 00000000 00000101 => 5

## 8.삼항 연산자

- 기본 형식  
  조건식 ? (조건식이 true일 때 남는 식) : (조건식이 false 일 때 남는 식)

- 자바는 조건식은 반드시 `boolean을 리턴`

## 9. 할당 연산자

- =  
  오른쪽의 데이터를 왼쪽의 변수가 가리키도록 하는 연산자
- 연산자=  
  왼쪽의 데이터 와 오른쪽의 데이터를 연산자를 이용해서 연산을 수행하고 그 결과를 왼쪽의 변수가 가르키도록 하는 연산자

  ```java
  int a = 10;
  a+=20;
  System.out.println(a) // a=30

  ```

- 변수의 값을 1 증가시키는 방법
  - a++; > a+=1 > a = a+1;

## 10. 문자열의 + 연산자

- `문자열은 모든 데이터와 + 연산 가능`
- 기본형 데이터의 경우는 문자열로 형 변환을 해서 결합  
  나머지 데이터는 toString 메서드를 호출해 그 결과를 결합하는 방식
- 문자열 리터럴은 `static 영역`에 저장되기 때문에 내용 변경 안됨  
  문자열을 + 로 결합하면 메모리 낭비 발생  
  `문자열 + 연산`은 자주 사용하지 않는 것을 권장하고 **String.format** 이나 **StringBuilder** 사용 권장
  - java 1.7 부터 문자열 + 연산을 자바가 내부적으로 Builder 를 이용해 수행함

---

# 제어문

## 1. java 에서의 import

- java 는 애플리케이션을 실행하면 `jdk 가 제공하는 클래스는 jre가 제공`을 해주고  
  `우리가 만든 모든 클래스를 jvm에 로딩`하여 실행
- 근본적으로 자바는 import 과정이 필요 없음
  - 메모리 가져오는 개념이 아니고 `줄여쓰기 위한 개념`

## 2. 콘솔에서 입력 받기

### java.io.BufferedReader 클래스

- 이 방법은 예외처리 강제

### java.util.Scanner 클래스

- .next자료형( ) 으로 문자열을 받아 자료형으로 변환 후 리턴

## 3. if

표현식 : 변수, 상수(리터럴은 제외), 연산식, 메서드 호출 구문

### 형식

```java
if(boolean이 리턴되는 표현식){
  true 수행 내용
}else if(){
  ...
}else{
  ...
}
```

- if는 필수
  - if는 1번만
- else if 는 0번 이상 여러 번 작성 가능
  - else if는 dead code(결코 수행되지 않는 code) 조건을 만들면 안 됌
- else 는 0번이나 한 번만 작성
  - else if 와 else 가 같이 사용되는 경우에는 `else 에서 예외적인 상황 처리`
    - try~catch 가 없을 때는 else 로 예외 처리

## 4. switch ~ case

값에 의한 분기

- 사용 가능한 데이터는 정수 와 문자열

### 기본 구조

```java
switch(정수나 문자열 표현식){
	case 값1:
		값1일 때 수행할 내용;
		(break;)
	case 값2:
		값2일 때 수행할 내용;
		(break;)
	...
	default:
		수행할 내용
		(break;)
}
```

- case 의 개수는 제한 없음
- case 에 사용하는 데이터는 `상수만 가능`합니다.
- break가 없으면 break를 만날때까지 모든 구문을 전부 수행

## 5. while

### 기본 구조

```java
while(boolean 표현식){
	boolean 표현식이 false 가 아니면 수행할 내용
}
```

- boolean 표현식이 false 가 될 때 까지 내용을 반복

## 6. do ~ while

### 기본 형식

```java
do{
	boolean 표현식이 false 가 아니면 수행할 내용
}while(boolean 표현식);
```

- boolean 표현식이 false 가 될 때 까지 내용을 반복
- `무조건 한 번은 수행한다`라는 의미를 전달할 목적으로 이용

## 7.for

### 기본형식

```java
for(초기식; boolean 표현식; 두번째부터 수행할 내용){
	boolean 표현식이 false 가 아닌 경우 수행할 내용
}
```

- 각 식은 생략 가능
- 각 식에는 `2개 이상의 문장을 사용`해도 됩니다.
  이 경우에는 ,로 구분

### 배열을 순회하면서 수행

```java
for(임시변수 : 배열){
	배열의 데이터를 임시변수에 하나씩 대입하면서 수행할 내용
}
```

### 배열 순회

```java
		for(int i=0, j=0; i<10 && j < 5; i++, j=j+2) {
			System.out.println(i);
			System.out.println(j);
		}

		String [] names = {"aespa", "redvelvet", "f(x)"};
		for(String name :  names) {
			System.out.println(name);
		}
```

## 8. 제어문 사용

- 실행할 내용이 한 줄 이면 { } 이면 생략 가능
- () 다음에 ;을 하게되면 제어문은 사용하지 않은 형태
- 제어문은 `별도의 블럭을 생성`하는데 이전 블럭에 만든 것을 다시 만들 수 없고  
  자신의 블럭 안에 만든 것은 자신의 블럭에서만 사용가능하고 제어문이 종료되면 블럭은 소멸
- switch 의 case 에서 변수를 만드는 것은 수행될 지 안될지를 모르기 때문에 불가

## 9. break 와 continue

- 반복문 안에서 사용되면 if 와 함께 사용

### break

- switch 와 반복문 안에서 `switch 와 반복문을 종료`하는 기능
- `break 다음에 수행할 내용이 없다면` break 대신에 `자신을 호출한 메서드에게 제어권을 넘기는 return`으로 작성

### continue

- 반복문 안에서 더 이상 아래로 내려가지 않고 `다음 반복으로 넘어가는 기능`

## 10. 무한 반복 만들기

```java
while(true){무한 반복}

do{무한 반복}while(true);

for(;;){무한 반복}
```

## 11. 반복문에 레이블 사용

```java
레이블:반복문{}
```

- break 나 continue를 할 때 뒤에 레이블을 붙일 수 있음
- 반복문 안에 반복문이 있을 때 바깥쪽 반복문을 종료하거나 넘어가고자 할 때 사용

# Array(배열)

## 1. Array

- `동일한 자료형`으로 구성된 데이터의 `연속적인 모임`
- 자바에서의 Array는 정적  
  한 번 만들어지면 `내부 요소의 수정은 가능하지만 크기 변경은 어려움`
- 데이터는 **Heap**에 생성
  - 동일한 용도로 사용되는 데이터는 이름이 하나인게 관리하기 편리하기 때문
- 여러 개의 데이터를 반복문 이나 iterator를 이용해서 쉽게 사용
- 배열은 하나의 public 속성을 갖는데 속성은 length
  배열이름.length 를 호출하면 한 단계 아래 `하위 데이터의 개수를 리턴`
  - length 속성은 `읽기 전용`

## 2. 배열의 생성

### 초기 데이터를 가지고 생성

- 선언할 때 만 가능
  ```java
  배열요소 1개의 자료형 [ ] 배열이름 = {데이터 나열..};
  ```

### 크기만 설정

```java
배열요소 1개의 자료형 [ ] 배열이름 = new 배열요소 1개의 자료형[개수];
```

- 개수만큼의 저장 공간이 확보되고 `자동 초기화를 수행`

  - 숫자의 경우는 0
    boolean 의 경우는 false
    나머지는 null

- 다시 선언하는 것도 가능
  ```java
  배열이름 = new 배열요소 1개의 자료형[개수];
  ```

### [ ]는 배열 이름 뒤에 기재 가능

- 자바에서는 대부분 앞에 기재
  자료형[ ]: 배열

## 3. 배열의 요소 접근

```java
배열이름[인덱스] // 인덱스는 0부터 length - 1 까지
```

## 4. 배열의 순회

```java
for(임시변수 : 배열이름){
  배열의 데이터를 순차적으로 하나씩 임시변수에 대입하고 수행
  }

    	//데이터를 가지고 배열 생성
    	String [] soccers = {"반바스텐", "굴리트", "리카르도", "차범근"};
    	//배열의 데이터 순회
    	int len = soccers.length;
    	for(int i=0; i<len; i=i+1) {
    		String imsi = soccers[i];
    		System.out.println(imsi);
    	}

    	//생성하고 데이터를 대입
    	int [] ar = new int[3]; //숫자는 0으로 초기화
    	ar[0] = 20;
    	ar[1] = 30;
    	//배열의 순회
    	for(int temp : ar) {
    		System.out.printf("%5d", temp);
    	}
```

## 5. 배열 사용 시 많이 발생하는 예외

- **NullPointerException**  
  `배열의 메모리 할당이 이루어지지 않은 상태`에서 사용
- **ArrayIndexOutOfBoundsException**  
  `인덱스 오류`

## 6. 다차원 배열

- 배열의 배열
- 배열 안의 요소가 배열인 형태
- [ ] 의 개수를 `차원의 개수`
  - 2차원 배열은 matrix
  - 3차원 배열이나 4차원 배열은 머신러닝에서 주로 이용

### 2차원 배열 생성

```java
// 초기 데이터를 가지고 생성
자료형 [][] 배열이름 = {{데이터 나열}, {데이터 나열} ,....};

// 각 행의 열 숫자가 동일한 경우
자료형 [][] 배열이름 = new 자료형 [크기][크기];

// 열의 숫자를 다르게 생성
자료형 [][] 배열이름 = new 자료형 [크기][];
배열이름[0] = new 자료형[크기];
```

### 2차원 배열 사용

- 배열이름[행인덱스][열인덱스]  
  데이터에 접근
  - 배열이름[행인덱스]는 배열

### 2차원 배열에서의 length

- 배열이름.length  
  행의 개수
- 배열이름[행인덱스].length  
  열의 개수

### 다차원 배열의 1차원화

배열은 셍상시 `마지막을 가리키기 위해서 메모리를 사용`  
`메모리를 아끼고자 할 때`는 2차원 배열을 1차원 배열로 만드는 것도 고려

```java
//2차원 배열
String [][] programmers =
{{"데니스 리치히", "비야네 스트로스트롭", "아네르스 하일스베르"},
			{"귀도 반 로섬", "제임스 고슬링", "켄 톰슨"}};
System.out.println(programmers.length);//행의 개수
System.out.println(programmers[0].length);//열의 개수
for(String [] ar : programmers) {
  for(String designer : ar) {
  System.out.print(designer + "\t");
  }
  System.out.println();
}

String [] langugeDesigner =
{"데니스 리치히", "비야네 스트로스트롭", "아네르스 하일스베르",
"귀도 반 로섬", "제임스 고슬링", "켄 톰슨"};
for(int i=0; i<langugeDesigner.length; i++) {
  System.out.print(langugeDesigner[i] + "\t");
  if(i % 3 == 2) {
  System.out.println();
  }
}
```

## 7. 배열에 데이터 추가

### `배열은 크기 변경이 불가`

- 배열의 크기를 변경하고자 할 때는 `배열의 데이터를 복사해서 수행`
  - **직접** 알고리즘을 구현
  - Arrays 클래스의 static 메서드인 **Arrays.copy** 를 이용
    `복사할 배열 과 개수`를 매개변수로 대입

## 8. 배열의 데이터를 하나의 문자열로 만들기

### 배열은 toString 메서드가 재정의되지 않음

- 문자열로 만들고자 하는 경우 **Arrays.toString 메서드**에 `매개변수로 대입해서 결과를 리턴`
- Arrays.toString은 `배열 안의 모든 요소의 toString을 호출해서 결합`
  ```java
    	String [] ar = {"레지밀러", "찰스바클리", "스캇피펜"};
    	//위의 배열의 내용을 가지고 데이터를 1개 추가한 배열을 생성
    	//직접 복제
    	String [] br = new String[ar.length + 1];
    	//배열의 요소 복제
    	for(int i=0; i<ar.length; i++) {
    		br[i] = ar[i];
    	}
    	//배열을 복제
    	String [] cr = Arrays.copyOf(ar, ar.length + 1);
    	cr[3] = "하킴 올라주원";
    	//배열을 요소들을 하나의 문자열로 생성
    	System.out.println(Arrays.toString(cr));
  ```

## 9. Sorting

- 배열은 데이터가 여러 개 이므로 접근을 할 때 `원하는 순서대로 접근`할 수 있도록 정렬
  - **직접** 알고리즘을 구현
  - Arrays 클래스가 제공하는 **sort 라는 메서드**를 이용.
- 대부분 API가 제공하는 메서드는 `Quick Sort 나 Heap 또는 Merge Sort`
  `선택 정렬이나 버블 정렬`은 학습 단계에서 반복문을 공부할 목적  
  애플리케이션에서는 성능이 떨어지기 때문에 잘 사용하지 않음

- **Arrays.sort 메서드**는 기본적으로 크기 비교가 가능한 메서드를 소유해야 함
  - 이를 직접 구현해서도 가능
  - 기본은 오름차순

### Arrays.sort 메서드를 이용한 데이터의 정렬

- `숫자 데이터 와 문자열 그리고 Date 클래스`의 배열은 별도로 메서드를 구현하지 않아도 오름차순 정렬이 가능
  - Wrapper 클래스 와 String 그리고 Date는 `Comparable 이라는 인터페이스가 구현`
  ```java
  //문자열을 오름차순 정렬
  Arrays.sort(cr);
  System.out.println(Arrays.toString(cr));
  ```

### 선택 정렬(Selection Sort)

첫번째 데이터 부터 마지막 바로 앞 데이터까지 `자신의 뒤에 있는 모든 데이터와 비교해서 정렬`해나가는 방식

- 앞의 데이터가 클 때 데이터를 교환하면 오름차순 정렬
  뒤의 데이터가 클 때 데이터를 교환하면 내림차순 정렬

```java
//1 5 3 2 4
//기준 비교
//첫번째 자리의 데이터 두번째 자리부터 끝까지의 데이터
//1 5 3 2 4
//두번째 자리의 데이터 세번째 자리부터 끝까지의 데이터
//1 2 5 3 4
//세번째 자리의 데이터 네번째 자리부터 끝까지의 데이터
//1 2 3 5 4
//네번째 자리의 데이터 다섯번째 자리부터 끝까지의 데이터
//1 2 3 4 5

int [] ar = {1, 5, 3, 2, 4};
//선택 정렬
//첫번째 부터 마지막 앞 자리까지
for(int i=0; i<ar.length - 1; i++) {
//기준의 뒤부터 마지막 자리까지
  for(int j=i+1; j<ar.length; j++) {
  //자리의 데이터를 비교해서 기준 자리의 데이터가 크면
  //2개의 데이터를 swap
  if(ar[i] > ar[j]) {
    int temp = ar[i];
    ar[i] = ar[j];
    ar[j] = temp;
  }
  }
//하나의 pass가 완료되면 출력
System.out.println(Arrays.toString(ar));
}
```

## 10.search(검색)

### 검색 알고리즘

- 순차 검색  
  데이터를 정렬하지 않은 상태에서 처음부터 끝까지 데이터를 찾을 때까지 비교해나가는 방식
- 제어 검색  
  데이터를 정렬한 상태에서 검색
- binary search  
  중앙에 있는 데이터 와 비교해서 같으면 찾은 것  
  작으면 왼쪽 부분의 배열에 다시 중앙값과 비교  
  오른쪽의 배열에서 중앙값과 비교하면서 찾는 방식

- fibonacci search  
  피보나치 수열의 순서대로 검색해나가는 방식

  - fibonacci 수열  
    첫번째 와 두번째는 1이고 세번째 부터는 앞의 2개 항의 합인 수열
    1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89....

- interpolation search  
  찾는 위치를 계산해서 찾는 방식

  - ((검색값 - 최소값)/(최대값-최소값)) \* (최대인덱스 - 최소인덱스) + 1 을 해서 찾는 위치를 결정
  - 데이터의 간격이 균등할 때 효과적

- tree search  
  데이터를 저장할 때 tree 구조로 저장해서 검색에 활용

- block search  
  블록끼리는 정렬이 되어 있고 블럭 내부는 정렬이 되지 않은 경우 사용

- hasing  
  데이터에 key를 생성해서 찾아가는 방식으로 가장 빠르지만 메모리 효율은 떨어집니다.
