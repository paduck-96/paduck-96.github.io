---
title: "반응형 웹, 자바스크립트의 문법 일부"
excerpt: "반응형 웹에 어울리는 flex와 grid. 자바스크립트에 대한 설명과 기본 문법까지..."

categories:
  - Blog
tags:
  - [Blog, kakaocloudschool, develop, responsive web, javascript]

toc: true
toc_sticky: true

date: 2022-11-05
last_modified_at: 2022-11-05
---

<pre>
**OOP
1.class
=>유사한 모양의 객체를 만들기 위한 템플릿
=>생성자를 이용해서도 생성이 가능하지만 생성자를 이용하게 되면 모든 멤버를 생성자 안에서 만들어야 하기 때문 객체가 가져야 하는 메서드가 많아지면 코드가 가독성이 떨어지게 됩니다.
=>ECMA2015(ES6) 에서 class 문법을 추가시킴

1)선언
=>기본적인 방법
class 클래스이름 {
	클래스 내용
}

=>상속을 받는 경우
class 클래스이름 extends 상위클래스이름{
	클래스 내용
}

=>표현식을 이용
let 이름 = class{클래스 내용}

let 이름 = class 내부에서사용할이름{클래스 내용}

=>클래스 이름은 일반적으로 첫글자를 대문자로 합니다.

2)클래스를 이용한 객체 생성 - 클래스를 이용해서 생성된 객체를 Instance 라고 합니다.
=>클래스의 생성자는 클래스 이름 과 동일하게 만들어지기 때문에 생성자 이름 대신에 클래스 이름을 기재해도 됩니다. 
var(let 또는 const 가능) 이름 = new 생성자이름(매개변수);
=>new 연산자는 생성자를 호출해서 인스턴스를 heap 영역에 만들고 그 참조를 리턴하는 연산자입니다.

3)클래스 안에 멤버 속성 만들기
=>메서드 안에서 this 와 이름을 만들면 인스턴스의 속성이 됩니다.

4)JavaScript에서의 class 는 정적이지 않습니다.
=>JavaScript 에서는 class 의 내용을 수정할 수 있습니다.
=>Class 가 prototype 이라는 내부 객체를 이용해서 모든 속성을 저장합니다.
prototype이 객체라서 확장이 가능합니다.
=>클래스를 선언할 때는 없었는데 나중에 추가하거나 변경하고자 하면 클래스이름.prototype.속성이름 = 내용 으로 클래스에 속성을 추가하는 것이 가능

5)이름
=>javascript에서는 값이나 함수 나 클래스 나 객체 모두 동일한 데이터로 취급
=>하나의 이름에 한 가지만 저장이 가능합니다.
중복 정의(Overloading)가 안됨

setName(){this.name="a"}
setName = function(){this.name="a";}

setName(name){this.name=name}
setName = function(name){this.name = name;}

6)Constructor(생성자)
=>인스턴스를 생성하고 그 참조를 리턴하는 특별한 목적의 메서드
=>메서드에서 this.속성이름 을 이용해서 인스턴스의 속성을 생성할 수 있습니다.
일반 메서드에서 속성을 생성하는 경우 메서드 호출을 하지 않으면 속성을 사용할 수 가 없습니다.
=>생성자는 인스턴스를 생성하기 위해 호출하는 메서드기 때문에 인스턴스를 만들려면 반드시 한 번은 호출해야 합니다.
생성자에서 필요한 속성을 만들면 속성을 만들기 위해서 다른 메서드를 호출하는 번거로움을 없앨수 있습니다.
=>javascript 에서는 constructor 라는 속성에 생성자를 만들어서 대입할 수 있습니다.
=>생성자는 1개만 만들 수 있는 기본적으로 매개변수가 없고 아무일도 하지 않는 생성자가 1개 제공됩니다.
생성자를 직접 만들면 제공되는 생성자는 소멸됩니다.
=>생성자를 호출하는 방법은 new 생성자이름(매개변수 나열) -> 실제로는 클래스이름.prototype.constructor 가 호출됩니다.

7)getter & setter - 접근자 메서드
=>인스턴스 안에 존재하는 속성의 데이터를 변경하고 리턴하는 메서드
=>getter 는 속성의 데이터를 리턴하는 메서드
일반적으로 매개변수는 없고 속성의 데이터만 리턴합니다.
이름은 get속성이름 으로 만드는데 속성 이름의 첫글자는 대문자로 표기합니다. - camel 표기법
Boolean 인 경우는 get 대신에 is를 사용하기도 합니다.

=>setter 는 속성의 데이터를 설정하는 메서드
매개변수는 1개(데이터 전체) 또는 2개(배열이나 객체의 일부 속성을 변경하는 경우 인덱스나 속성이름을 매개변수로 추가하는 경우가 있습니다.)로 하는 것이 일반적이면 리턴을 하지 않습니다.
이름은 set속성이름 으로 만듭니다.

=>자바스크립트에서는 getter 앞에 get을 setter 앞에 set을 추가하면 데이터를 저장하는 속성처럼 사용하는 것이 가능합니다.
개발자들은 이 문법은 잘 사용하지 않습니다.

8)static
=>메서드 앞에 static을 붙이면 인스턴스가 아니라 클래스가 호출할 수 있는 속성이 됩니다.
=>static 이 붙으면 인스턴스가 호출할 수 없음
=>인스턴스의 메서드 안에서 static 메서드 호출하는 것은 가능
반대로는 되지 않음
클래스가 만들어지고 인스턴스가 생성되기 때문에 인스턴스 메서드를 호출하는 시점에는 클래스의 내용이 완성이 된 상태입니다.
그렇지만 클래스의 메서드를 호출하는 시점에는 인스턴스가 만들어져 있을 수도 있고 없을 수도 있기 때문에 클래스의 메서드에서 인스턴스의 메서드를 호출하는 것은 안됩니다.

2.상속
1)개념
=>상위 클래스의 모든 것을 하위 클래스가 물려받는 것
=>기본적으로는 클래스들을 만들다가 중복되는 내용이 나오면 중복되는 내용을 가지고 상위 클래스를 만들고 다른 클래스들에서 상속을 하는 형태를 취하게 됩니다.
화살표의 방향을 위에서 아래로가 아니라 아래에서 위로 그립니다.
객체 지향에서는 상속이라 하지 않고 is a 라고 합니다.
하나의 클래스 안에 다른 클래스의 인스턴스가 포함되는 경우는 has a 라고 합니다.

2)상속받는 방법
클래스 선언뒤에 extends 상위클래스이름{

}

3)super
=>하위 클래스에서 상위 클래스의 속성을 호출할 때 상위 클래스 인스턴스를 super 라고 합니다.
=>하위 클래스의 일반 메서드에서 상위 클래스에 만들어진 메서드를 호출하고자 할 때는 super.메서드이름() 의 형태로 호출합니다.
=>constructor 안에서 상위 클래스의 constructor를 호출하고자 하는 경우는 super( )로 호출합니다.

4)method overriding(재정의)
=>상위 클래스의 메서드 와 동일한 모양의 메서드를 하위 클래스에서 다시 정의하는 것
=>목적은 기능 확장
상위 클래스의 메서드를 가지고 그대로 사용하는 것이 부족해서 추가하기 위해서 입니다.
=>새로운 기능을 만들거라면 overriding을 하면 안됩니다.
=>메서드의 기능이 생성하는 거라면 상위 클래스의 것을 먼저 호출해야하고 정리하는 거라면 상위 클래스의 것을 나중에 호출해야 합니다.
=>최근의 언어에서는 내용이 없는 메서드에 내용을 채우는 것을 overriding 이라고 하지 않습니다.

3.Iteration
=>순차적 처리를 위한 것
=>모든 데이터가 순차적 처리를 할 수 있는 것은 아니고 Javascript에서는 Iterable 프로토콜 과 Iterator 프로토콜을 준수해야만 순차적 처리가 가능합니다.
=>순차적 처리가 가능한 대표적인 데이터가 Array(배열)
=>순차적 처리가 가능한 데이터에는 Symbol.iterator가 존재해야 합니다.
=>Symbol.iterator 속성을 추출해서 next 메서드를 호출하면 순차적으로 처리가 가능
=>직접 만들고자 할 때는 Generator 와 Symbol 내장 객체를 이용해야 합니다.

4.for-of
=>for - in 은 객체 나 배열의 모든 속성을 순차적으로 접근하기 위한 명령문
=>for - of 는 순차적 처리가 가능한 데이터를 순회하는 명령문

5.Destructuring - 구조 분해 할당 또는 비구조화 할당
1)개념
=>데이터를 나누어서 저장
=>다른 언어에서는 Tuple 이라고 합니다.

2)배열
=>순서대로 할당

3)인스턴스
=>변수의 이름 과 속성의 이름을 맞추어서 할당

4)파라미터 설정에도 가능

5)spread 연산 & rest param
=>구조 분해 할당을 할 때 나머지를 전부 할당하는 연산을 spread 연산이라고 하고 파라미터에 적용하면 rest param 이라고 함
=>할당할 변수 앞에 ... 을 붙여주면 됩니다.

6)기본값을 설정해서 구조 분해 할당 가능

6.Exception Handling(예외 처리)
1)용어
=>error
물리적 에러: 잘못된 문법으로 프로그램이 실행되지 않는 상황
논리적 에러: 문법에 맞게 작성했는데 알고리즘을 틀리게 설계해서 잘못된 결과가 나오는 경우

=>exception(예외)
문법에는 맞아서 번역은 되는데 특수한 상황이 발생해서 프로그램이 중단되는 현상

=>assertion(단언)
에러가 없고 예외가 발생하는 상황이 아니지만 개발자가 강제로 예외를 발생시켜 프로그램을 중단하는 것

=>Debugging
코드를 작게 쪼개서 실행시키면서 논리적 에러나 예외 발생 지점을 찾아내는 것

=>Test
예전에는 테스트를 개발이 종료되고 난 후 하는 경우가 많았는데 최근에는 개발 과정에 테스트를 하기도 합니다.
이를 TDD(테스트 주도 개발)라고 합니다.

2)예외 처리
=>예외가 발생했을 때 어떻게 할 것인가를 작성하는 것
=>목적
예외가 발생하더라도 계속해서 프로그램을 실행시키기 위해서
예외를 로깅(기록)하기 위해서

3)예외 처리 기본 구조
try{
	예외 발생 가능성이 있는 코드
}catch(예외처리 변수){
	예외가 발생했을 때 수행할 코드
}finally{
	예외 발생 여부에 상관없이 수행할 코드
}
=>finally는 생략이 가능
=>예외가 발생하면 예외 객체가 예외처리 변수에 자동으로 대입됩니다.
=>언어에 따라서는 catch를 여러 개 만들 수 있는 것도 있고 catch를 생략하고 finally만 적어도 되는 경우가 있음
- 자바스크립트는 catch를 1개만 작성할 수 있고 catch 대신 finally를 사용할 수 있음
=>finally에는 대부분의 경우 정리 작업을 수행하는 코드를 작성합니다.

3)예외 객체
=>예외가 발생했을 때 catch에 전달되는 객체
=>속성
message: 예외 발생 이유
description: 예외 설명
name: 예외 이름

4)강제로 예외 발생
=>throw 예외메시지
=>throw new Error(예외 메시지)

7.Module Programming
=>프로그램을 분할해서 작성하는 것
=>일반적인 언어에서는 클래스 단위로 분할하는 것이 일반적입니다.
함수 단위로 분할하는 경우도 있습니다.
화면 단위로 분할하기도 합니다.

1)export
=>현재 모듈의 내용을 내보내서 외부에서 사용할 수 있도록 해주는 기능
=>export 데이터 형태로 내보냄
=>export default 데이터 형태로 내보낼 수 있는데 이 경우는 명시적으로 1개만 내보고자 할 때 사용합니다.
이 코드는 하나의 모듈에 1번만 작성되어야 합니다.

//각자 내보내기
export 내보내고자하는 데이터(값, 함수, 클래스) 나열

//여러 개를 묶어서 내보내기
export {내보내고자 하는 데이터 나열..}

//이름을 변경해서 내보기
export {원래이름 as 다른이름...}

//구조 분해 할당을 이용한 내보내기
export {이름 나열} = 객체 나 배열

//1개만 내보내고자 하는 경우
export default 데이터;

2)import
=>다른 모듈에서 export 한 내용을 가져와서 사용하기 위한 명령어

//default 로 내보낸 데이터를 가져오기
import 이름 from "모듈이름";

//내보낸 모든 데이터를 하나의 이름으로 가져오기
import * as 이름 from "모듈이름";

//내보낸 데이터 중 일부분만 가져오기
import {이름} from "모듈이름"; //모듈에서 이름에 해당하는 것만 가져와서 사용하는데 여러 개를 가져오고자 하면 ,로 구분해서 이름을 나열하면 됩니다.

//내보낸 데이터 중 일부분만 가져오기
import {이름} from "모듈이름"; //모듈에서 이름에 해당하는 것만 가져와서 사용하는데 여러 개를 가져오고자 하면 ,로 구분해서 이름을 나열하면 됩니다.

//이름을 변경해서 사용하는 경우
import {이름 as 다른이름} from "모듈이름";

**Built-In(제공하는) Object
1.종류
1)일반 객체
=>javascript 에서 제공하는 일반적인 객체 - 브라우저와 상관없이 동작

2)BOM(Browser Object Model)
=>브라우저 차원에서 제공하는 객체

3)DOM(Document Object Model)
=>HTML 의 body 부분에 만드는 태그들을 사용하기 위한 객체

2.Document
=>https://www.w3schools.com/jsref/default.asp
=>https://devdocs.io/javascript

3.일반 내장 객체
1)Object
=>Javascript의 최상위 객체
=>Javascriptdpt는 모든 객체가 이 객체를 상속받음
=>객체 생성 방법
{ }
new Object()

=>주요 속성이나 메서드
prototype 속성: 이 속성에 데이터를 추가하면 모든 객체를 데이터를 사용할 수 있습니다.
toString 메서드: 객체를 문자열로 변환하는 메서드로 출력하는 메서드에 객체 이름을 대입하면 자동으로 호출되는 메서드

2)Number 객체
=>숫자와 관련된 객체
=>객체를 생성할 때는 숫자를 직접 대입해도 되고 new Number(숫자로 구성된 문자열)

3)Math 객체
=>Java의 Math 클래스를 그대로 가져옴
=>인스턴스 생성을 하지 않음(new 를 하지 않음) - 모든 멤버가 static

4)String
=>문자열 클래스
=>생성
큰 따옴표나 작은 따옴표 안에 문자열 리터럴을 대입해서 생성할 수 있고 new String(문자열)을 이용해서 생성하는 것이 가능
=>length 속성: 문자열의 길이
=>charAt(인덱스): 인덱스 번째 문자를 리턴
=>문자열 관련 작업 중 중요한 것
좌우 공백 제거?
영문 대소문자 문제?
특정한 패턴의 문자 나 문자열의 존재 여부?
불용어 사용
한글을 사용할 때는 인코딩 문제

=>연습문제
var str = "CGCCGDKSKDGCCGCCGDKDGCCGDS";
//이 문자열에서 GCCG를 찾아서 첫글자의 위치를 전부 출력하시오
//앞에서 사용한 데이터는 다시 사용하면 안됩니다.

[1, 10,  20]
</pre>
