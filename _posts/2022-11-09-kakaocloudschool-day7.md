---
title: "OOP의 개념, Class와 Object에 대하여, 예외처리와 모듈화"
excerpt: "oop의 개념에 대해 학습하고,
class와 object에 대해 학습하고,
예외처리와 모듈화에 대한 개념을 학습한다"

categories:
  - Blog
tags:
  - [Blog, kakaocloudschool, develop, javascript, oop, class, object, exception handling, module]

toc: true
toc_sticky: true

date: 2022-11-09
last_modified_at: 2022-11-15
---

# OOP

## class

- 유사한 모양의 객체를 만들기 위한 템플릿
- 생성자를 이용해서도 생성이 가능하지만

  > 생성자 안에서 모든 멤버를 만들어야해서 객체의 메서드 증가, 가독성 감소

  - ECMA2015(ES6) 에서 class 문법을 추가시킴

1. 선언

- 기본적인 방법

  ```javascript
  class 클래스이름 {
  클래스 내용
  }
  ```

- 상속을 받는 경우

  ```javascript
  class 클래스이름 extends 상위클래스이름{
  클래스 내용
  }
  ```

- 표현식을 이용

  ```javascript
  let 이름 = class{
  클래스 내용
  }

  let 이름 = class 내부에서사용할이름{
  클래스 내용
  }
  ```

- 클래스 이름은 일반적으로 `첫글자를 대문자`로 합니다.

2. 클래스를 이용한 객체 생성  
   `클래스를 이용해서 생성된 객체`는 **Instance**

- 클래스의 생성자  
  클래스 이름 과 동일해 생성자 이름 대신에 클래스 이름을 기재 가능

  ```javascript
  var(let 또는 const 가능) 이름 = new 생성자이름(매개변수);
  ```

  - new 연산자  
    생성자를 호출해 `heap 영역에 인스턴스를 만들고 그 참조를 리턴`

3. 클래스 안에 멤버 속성 만들기

   > 메서드 안에서 this 와 이름을 만들면 인스턴스의 속성이 됩니다.

4. JavaScript에서의 class 는 정적이지 않다
   > JavaScript 에서는 class 의 내용을 수정할 수 있음

- Class 가 prototype 이라는 내부 객체를 이용해서 모든 속성을 저장
  - prototype은 객체라서 확장 가능
  - 나중에 추가하거나 변경
    ```javascript
    클래스이름.prototype.속성이름 = 내용;
    ```

5. 이름  
   javascript에서는 값이나 함수 나 클래스 나 객체 모두 동일한 데이터로 취급

- 하나의 이름에 한 가지만 저장이 가능

  - 중복 정의(Overloading)가 안됨

  ```javascript
  setName(){
  this.name="a"
  }
  setName = function(){
  this.name="a";
  }

  setName(name){
  	this.name=name
  	}
  setName = function(name){
  	this.name = name;
  	}

  ```

6. Constructor(생성자)

   > 인스턴스를 생성하고 그 참조를 리턴하는 특별한 목적의 메서드

`메서드에서 this.속성이름 을 이용해서 인스턴스의 속성 생성 가능`

- 일반 메서드에서 속성을 생성하는 경우  
  메서드 호출을 하지 않으면 속성을 사용할 수 가 없다
- 생성자는 인스턴스를 생성하기 위해 호출하는 메서드로 반드시 한 번은 호출
  - 생성자에서 필요한 속성을 만들면 속성을 만들기 위해서 다른 메서드를 호출 불필요
- javascript 에서는 constructor 라는 속성에 생성자를 만들어서 대입
  - 생성자는 기본적으로 1개만 만들 수 있는 매개변수가 없고 아무일도 하지 않는 생성자가 1개 제공
    - 생성자를 직접 만들면 제공되는 생성자는 소멸
- 생성자를 호출 방법

  ```javascript
  new 생성자이름(매개변수 나열)
  //실제로는 클래스이름.prototype.constructor 가 호출
  ```

7. getter & setter  
   접근자 메서드

- 인스턴스 안에 존재하는 속성의 데이터를 변경하고 리턴하는 메서드

  - getter  
    `속성의 데이터를 리턴하는 메서드`

    - 일반적으로 매개변수는 없고 속성의 데이터만 리턴
      - get속성이름 으로 만드는데 속성 이름의 첫글자는 대문자
        - Boolean 인 경우는 get 대신에 is를 사용하기도 합니다.

  - setter  
     `속성의 데이터를 설정하는 메서드`
    - 매개변수 1개  
      데이터 전체
    - 매개변수 2개  
      배열이나 객체의 일부 속성을 변경하는 경우
      - 인덱스나 속성이름을 매개변수로 추가하는 경우
    - 리턴을 하지 않음
    - 이름은 set속성이름

- 자바스크립트에서는 getter 앞에 get을 setter 앞에 set을 추가하면 데이터를 저장하는 속성처럼 사용하는 것이 가능

  - 개발자들은 이 문법은 잘 사용하지 않음

8. static

- 메서드 앞에 static을 붙이면 인스턴스가 아니라 클래스가 호출할 수 있는 속성

  - static 이 붙으면 인스턴스가 호출할 수 없음
  - 인스턴스의 메서드 안에서 static 메서드 호출하는 것은 가능하나 반대 불가
    > 클래스가 만들어지고 인스턴스가 생성되기 때문에  
    > 인스턴스 메서드를 호출하는 시점에 클래스의 내용은 이미 완성  
    > 그렇지만 클래스의 메서드를 호출하는 시점에는 몰라 클래스의  
    > 메서드에서 인스턴스의 메서드를 호출하는 것은 불가

## 상속

1. 개념

   > 상위 클래스의 모든 것을 하위 클래스가 물려받는 것

   - 기본적으로는 클래스들을 만들다 중복되는 내용이 나오면  
     중복되는 내용을 가지고 상위 클래스를 만들고
   - 다른 클래스들에서 상속을 하는 형태
   - 화살표 방향은 위에서 아래로가 아니라 아래에서 위로
   - 객체 지향에서는 상속이 아닌 is a
     - 하나의 클래스 안에 다른 클래스 인스턴스가 포함되는 경우는 has a

2. 상속받는 방법

   ```javascript
   클래스 선언뒤에 extends 상위클래스이름{

   }
   ```

3. super

- `하위 클래스 호출하는 상위 클래스의 인스턴스`

  - 하위 클래스의 일반 메서드에서 상위 클래스 메서드 호출

    ```javascript
    super.메서드이름();

    //constructor 안에서 상위 클래스의 constructor를 호출
    super();
    ```

4. method overriding(재정의)

   > 상위 클래스의 메서드 와 동일한 모양의 메서드를 하위 클래스에서 재정의

   - 목적은 기능 확장

- 상위 클래스의 메서드를 가지고 그대로 사용하는 것이 부족해 추가 목적
  - `새로운 기능을 만들거라면 overriding을 하면 안됌`
    - 메서드의 기능이 생성  
      상위 클래스의 것을 먼저 호출
    - 메서드의 기능이 정리  
      상위 클래스의 것을 나중에 호출
- 최근의 언어에서는 내용이 없는 메서드에 내용을 채우는 것은 overriding 이 아님

## Iteration

### 순차적 처리를 위한 것

- 모든 데이터가 순차적 처리를 할 수 있는 것은 아님  
  Javascript에서는 Iterable 프로토콜 과 Iterator 프로토콜을 준수해야만 순차적 처리가 가능

  - 순차적 처리가 가능한 대표적인 데이터가 Array(배열)
  - 순차적 처리가 가능한 데이터는 Symbol.iterator가 존재

    - Symbol.iterator 속성 추출해 next 메서드를 호출하면 순차 처리 가능
    - 직접 만들고자 할 때는 Generator 와 Symbol 내장 객체를 이용

## for- of

- for - in  
  객체 나 배열의 모든 속성을 순차적으로 접근하기 위한 명령문
- **for - of**  
  순차적 처리가 가능한 데이터를 순회하는 명령문

## Destructuring

### 구조 분해 할당 또는 비구조화 할당

1. 개념

- `데이터를 나누어서 저장`
  - 다른 언어에서는 Tuple

2. 배열  
   순서대로 할당

3. 인스턴스  
   변수의 이름 과 속성의 이름을 맞추어서 할당

4. 파라미터 설정 가능

5. spread 연산 & rest param
   - **spread**  
     구조 분해 할당을 할 때 나머지를 전부 할당하는 연산
   - 할당된 변수 앞에 ... 추가

- rest param
  이를 파라미터에 적용한 것

6. 기본값을 설정해서 구조 분해 할당 가능

## Exception Handling(예외 처리)

1. 용어

   - error

     - 물리적 에러  
       잘못된 문법으로 프로그램이 실행되지 않는 상황
     - 논리적 에러  
       문법에 맞게 작성하나, 알고리즘을 틀리게 설계해 잘못된 결과가 나오는 경우

   - exception(예외)  
     문법에는 맞아서 번역은 되는데 `특수한 상황이 발생해서 프로그램이 중단되는 현상`

   - assertion(단언)  
     에러가 없고 예외가 발생하는 상황이 아니지만 `개발자가 강제로 예외를 발생시켜 프로그램을 중단`하는 것

   - Debugging  
     코드를 작게 쪼개서 실행시키면서 논리적 에러나 예외 발생 지점을 찾아내는 것

   - **Test**  
     예전에는 테스트를 개발이 종료되고 난 후 진행  
     최근에는 개발 과정에 테스트 진행
     - TDD(테스트 주도 개발)

2. 예외 처리
   > 예외가 발생했을 때 어떻게 할 것인가를 작성하는 것

- 목적
  - 예외가 발생하더라도 계속해서 프로그램을 실행시키기 위해
  - 예외를 로깅(기록)하기 위해

3. 예외 처리 기본 구조

   ```javascript
   try{
   	예외 발생 가능성이 있는 코드
   }catch(예외처리 변수){
   예외가 발생했을 때 수행할 코드
   }finally{
   예외 발생 여부에 상관없이 수행할 코드
   }
   ```

   - finally는 생략이 가능

- 예외가 발생하면 예외 객체가 예외처리 변수에 자동으로 대입

  - 언어에 따라서는 catch를 여러 개 만들 수 있음  
    catch를 생략하고 finally만 적어도 되는 경우가 있음

- 자바스크립트는 catch를 1개만 작성할 수 있고 catch 대신 finally 가능

  - finally에는 대부분의 경우 정리 작업을 수행하는 코드를 작성

- 예외 객체  
  예외가 발생했을 때 catch에 전달되는 객체

  - 속성

    - message  
      예외 발생 이유
    - description  
      예외 설명
    - name  
      예외 이름

- 강제로 예외 발생
  ```javascript
  throw 예외메시지
  throw new Error(예외 메시지)
  ```

## Module Programming

### 프로그램을 분할해서 작성하는 것

- 일반적인 언어에서는 클래스 단위로 분할하는 것이 일반적

  - | | 함수 단위로 분할
  - | | 화면 단위로 분할

- export  
   현재 모듈의 내용을 내보내서 외부에서 사용할 수 있도록 해주는 기능

  ```javascript
  export 데이터 형태
  export default 데이터 형태
  //명시적으로 1개만 내보고자 할 때 사용
  `이 코드는 하나의 모듈에 1번만 작성`

  //각자 내보내기
  export 내보내고자하는 데이터(값, 함수, 클래스) 나열

  //여러 개를 묶어서 내보내기
  export {내보내고자 하는 데이터 나열..}

  //이름을 변경해서 내보기
  export {원래이름 as 다른이름...}

  //구조 분해 할당을 이용한 내보내기
  export {이름 나열} = 객체 나 배열

  //1개만 내보내고자 하는 경우
  export default 데이터;
  ```

- import  
  다른 모듈에서 export 한 내용을 가져와서 사용하기 위한 명령어

  ```javascript
  //default 로 내보낸 데이터를 가져오기
  import 이름 from "모듈이름";

  //내보낸 모든 데이터를 하나의 이름으로 가져오기
  import \* as 이름 from "모듈이름";

  //내보낸 데이터 중 일부분만 가져오기
  import {이름} from "모듈이름";
  //모듈에서 이름에 해당하는 것만 가져와서 사용
  //여러 개를 가져오고자 하면 ,로 구분해서 이름 나열

  //이름을 변경해서 사용하는 경우
  import {이름 as 다른이름} from "모듈이름";
  ```

## Built-In(제공하는) Object

1. 종류

- 일반 객체  
  javascript 에서 제공하는 일반적인 객체

  - 브라우저와 상관없이 동작

- BOM(Browser Object Model)  
  브라우저 차원에서 제공하는 객체

- DOM(Document Object Model)  
  HTML 의 body 부분에 만드는 태그들을 사용하기 위한 객체

2. Document
   =>https://www.w3schools.com/jsref/default.asp
   =>https://devdocs.io/javascript

3. 일반 내장 객체

- Object  
  Javascript의 최상위 객체
  - Javascript에서는 모든 객체가 이 객체를 상속받음
- 객체 생성 방법

  ```javascript
  {
    내용;
  }
  new Object();
  ```

- 주요 속성이나 메서드

  - prototype 속성  
    이 속성에 데이터를 추가하면 모든 객체에서 데이터를 사용
  - toString 메서드  
    객체를 문자열로 변환하는 메서드
    - 출력하는 메서드에 객체 이름을 대입하면 자동으로 호출되는 메서드

- Number 객체  
  숫자와 관련된 객체

  - 객체 생성
    ```javascript
    숫자 직접 대입
    new Number(숫자로 구성된 문자열)
    ```

- Math 객체  
  Java의 Math 클래스를 그대로 가져옴

  > 인스턴스 생성을 하지 않음(new 를 하지 않음)

  - 모든 멤버가 static

- String  
  문자열 클래스
  - 생성
  ```javascript
  큰 따옴표나 작은 따옴표 안에 문자열 리터럴을 대입
  new String(문자열)
  ```
  - length 속성  
    문자열의 길이
  - charAt(인덱스)  
    인덱스 번째 문자를 리턴
    ```javascript
    문자열 관련 작업 중 중요한 것
    `좌우 공백 제거?`
    영문 대소문자 문제?
    특정한 패턴의 문자 나 문자열의 존재 여부?
    불용어 사용
    `한글을 사용할 때는 인코딩 문제`
    ```

#### 연습문제

```javascript
var str = "CGCCGDKSKDGCCGCCGDKDGCCGDS";
//이 문자열에서 GCCG를 찾아서 첫글자의 위치를 전부 출력하시오
//앞에서 사용한 데이터는 다시 사용하면 안됩니다.

[1, 10, 20];
```
